---
title: "Gràfics"
format: html
editor: visual
project:
  type: website
  output-dir: docs
---

# Gràfics

Les dades amb les que treballarem, segurament ja ho heu fet.

```{r, warning=FALSE, message=FALSE}
library(tidyverse) 
library(here) 
library(readxl) 
library(janitor) 
library(skimr) 
library(broom) 
library(rstatix) 

raw_data <- read_excel(here("Basic", "data", "PCR.xlsx"),  sheet = "relative")

data <- raw_data %>% 
  mutate(across(c(group, sex, rat, generation), as.factor)) 

longdata <- data %>% 
  pivot_longer(cols="gene_1":"gene_4", names_to="gene", values_to = "value" ) %>% 
  mutate(
      group = factor(group, 
                          levels = c("REF", "P", "G", "S", "PGS")), 
      generation = factor(generation, 
                          levels = c( "M", "Cd1", "Cd21", "CA")),
      gene = factor(gene,
                    levels = c("gene_1", "gene_2", "gene_3", "gene_4"))
                    )
```

Per a fer gràfics R ja et dona opcions per defecte, però per a triar i personalitzar certs aspectes és millor fer-ho amb `ggplot` (inclòs a `tidyverse`). Recomano molt tenir la Cheatsheet de `ggplot2` impresa per anar consultant les ocpions.

## PCR

Per a graficar les dades de PCR, farem un núvol de punts amb línia a la mitjana i barres d'error.

Comencem fent tot el que ja hem explicat

```{r, eval=FALSE}
#Carregar els paquets bàsics -------
library(tidyverse)
library(here)
library(readxl)
library(janitor)
library(skimr)

#Importar dades i preprarar-les-------
raw_data <- read_excel(here("data", "PCR.xlsx")) 

#crear dataset amb el que treballarem
data <- raw_data %>% 
  clean_names() %>%
  mutate(across(c(group, sex, rat, generation), as.factor)) 

skim(data) 

#creem long data
longdata <- data %>% 
  pivot_longer(cols="gene_1":"gene_4", names_to="gene", values_to = "value" ) %>% 
  mutate(
      group = factor(group, 
                          levels = c("REF", "P", "G", "S", "PGS")), 
      generation = factor(generation, 
                          levels = c( "M", "Cd1", "Cd21", "CA")),
      gene = factor(gene,
                    levels = c("gene_1", "gene_2", "gene_3", "gene_4")))
```

Seguidament podem fer un gràfic previ per veure com es comporten els gens en general, sense separar per generació.

```{r}
longdata %>%
  na.omit() %>% 
  group_by(generation) %>% 
  ggplot(aes(x=group, y=value, colour=generation))+ 
    geom_jitter(position = position_dodge(width = 0.6))+ 
    scale_x_discrete(limits = c("REF", "P", "G", "S","PGS"))+ 
    facet_wrap(~gene) 
```

Com podeu veure abans de fer el gràfic hem preparat les dades en la mateixa pipeline, ometent els NA i agrupant per generacions. Seguidament li hem demanat al gràfic:

-   `ggplot(aes(x=group, y=value, colour=generation))+` quin és l'eix de les x, quin és l'eix de les y i que determina el color

-   `geom_jitter(position = position_dodge(width = 0.6))+` fer un gràfic de punts amb els valors espaiats

-   `scale_x_discrete(limits = c("REF", "P", "G", "S","PGS"))+` l'ordre en que apareixen els grups a l'eix de les x

-   `facet_wrap(~gene)` indica que ho separi en mini gràfics, un per cada gen. També podriem fer servir `facet_grid(~)` per a separar-ho de manera més controlada, ho veurem al següent.

Definim el tema i els colors del grup:

```{r}
#canviar estil del gràfic default
theme_set(theme_classic()) 

#definim els colors que volem per grup
colors <- c("REF" = "#999999",   # Grey
            "PGS" = "#1b9e77",   # Green 1
            "S" = "#66a61e",   # Green 2
            "G" = "#a6d854",   # Green 3
            "P" = "#d9f0a3")   # Green 4
```

Anem a personalitzar-lo més i afegir les barres d'error i mitjana. Hi ha dues maneres de fer-ho, la primera és com ho feia inicialment però són més passos innecessaris, tot i que es controla més.

Primer canviem l'ordre en el que apareixeran els gens i el nom del grup de la generació per a que ens surti complet.

```{r}
#reordenar com sortiran els gens com interessi
gene_order <- c("gene_1", "gene_2", "gene_3", "gene_4")
longdata$gene <- factor(longdata$gene, levels = gene_order)

#com volem que surti el nom de la generació
generation_name <- c(
      M   = "Dams",
      Cd1 = "Day-1 offspring",
      Cd21= "Day-21 offspring",
      CA  = "Adult offspring"
    )
```

1.  Abans de res hem de crear un dataset que contingui la mitjana i error estàndard de cada grup per cada gen dins de cada generació.

```{r}
# Compute summary stats per a afegir al gràfic-------
summary_data <- longdata %>%
  na.omit() %>%
  group_by(generation, gene, group) %>% 
  summarise(
    mean = mean(value), #calculem mitjana
    se = sd(value)/sqrt(n()), #calculem error estàndard
    .groups = "drop" 
  )

summary_data$gene <- factor(summary_data$gene, levels = gene_order)
```

Ja podem fer el gràfic

```{r}
#GRÀFIC BO TOTALS------
ggplot <- longdata %>% #dataset a graficar en format "long"
  na.omit() %>% #no tenir en compte els NA
  ggplot(aes(x=group, y=value, colour=group))+ 
  geom_jitter()+ #gràfic punts
  scale_x_discrete(limits = c("REF", "P", "G", "S","PGS"), 
                   expand = expansion(add = 1))+ #afegir espai entre grups
  facet_grid(generation~gene, 
             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre 
  geom_hline(yintercept = 100, color = "black",linetype = "dotted", linewidth = 0.5)+
  geom_errorbar(data = summary_data, 
                aes(x = group, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+ #afegir barres d'error
  geom_errorbar( #afegir línia mitjana
    data = summary_data,
    aes(x = group,
        ymin = mean,
        ymax = mean,
        colour = group),
    width = 0.8,
    inherit.aes = FALSE,
    linewidth = 1)+ 
  scale_colour_manual(values=colors, 
                      breaks = c("REF", "P", "G", "S", "PGS"))+ 
  labs(title= "PCR small intestine", 
       x= "Group", 
       y= "Relative mRNA levels (%)",
       colour= "Group")+  
  theme(plot.title = element_text(hjust = 0.5), 
        strip.text.x = element_text(size = 12),
        strip.text.y = element_text(size = 12, hjust = 0.75),
        strip.background = element_blank(),
        panel.spacing = unit(0.5, "cm")) #espai entre els mini gràfics

ggplot
```

-   `geom_hline(yintercept = 100, color = "black",linetype = "dotted", size = 0.5)+` Afegim una línia de punts al 100

-   `geom_errorbar(data = summary_data, aes(x = group_name, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+` Afegim les barres d'error

-   `geom_errorbar(data = summary_data, aes( x = group, ymin = mean, ymax = mean, colour = group), width = 0.8, inherit.aes = FALSE, linewidth = 1 )+` Afegim línia a la mitjana.

-   `labs(title= "PCR small intestine", gràfic x= "Group",  eix x y= "Relative mRNA levels (%)", colour= "Group")+` Et permet canviar el nom dels eixos i títol i nom de la llegenda, en aquest cas ens la fa del color però també la podria fer per colour, fill, shape, linetype, size...

2.  Sense necessitat de fer un altre dataset amb les mitjanes, enlloc de `geom_errorbar(data = summary_data` , posem `stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.5)`per la barra d'error i `stat_summary(fun = mean, geom = "crossbar", width = 0.75)` per la mitjana. D'aquesta manera ja ho calcula ell i no hem de tenir dos datasets

```{r}
ggplot <- longdata %>% #dataset a graficar en format "long"
  na.omit() %>% #no tenir en compte els NA
  ggplot(aes(x=group, y=value, colour=group))+ 
  geom_jitter()+ #gràfic punts
  scale_x_discrete(limits = c("REF", "P", "G", "S","PGS"), 
                   expand = expansion(add = 1))+ #afegir espai entre grups
  facet_grid(generation~gene, 
             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre 
  geom_hline(yintercept = 100, color = "black",linetype = "dotted", linewidth = 0.5)+
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.5) +
  stat_summary(fun = mean, geom = "crossbar", width = 0.75)+
  scale_colour_manual(values=colors, 
                      breaks = c("REF", "P", "G", "S", "PGS"))+ 
  labs(title= "PCR small intestine", 
       x= "Group", 
       y= "Relative mRNA levels (%)",
       colour= "Group")+  
  theme(plot.title = element_text(hjust = 0.5), 
        strip.text.x = element_text(size = 12),
        strip.text.y = element_text(size = 12, hjust = 0.75),
        strip.background = element_blank(),
        panel.spacing = unit(0.5, "cm")) #espai entre els mini gràfics

ggplot
```

Un altre exemple seria triar només una generació, on només canvia el següent

```{r}
longdata %>%
  na.omit() %>% 
  filter(generation=="Cd1") %>% #afegim filtre!!
  ggplot(aes(x=group, y=value, colour=group))+
  geom_jitter()+
  scale_x_discrete(limits = c("REF", "P", "G","PGS"),
                   expand = expansion(add = 1))+
  facet_grid(~gene,    #només separem per gen
             labeller = labeller(gene = gene_order))+
  geom_hline(yintercept = 100, color = "black",linetype = "dotted", size = 0.5)+ 
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.5) +
  stat_summary(fun = mean, geom = "crossbar", width = 0.75)+
  scale_colour_manual(values=colors,
                breaks = c("REF", "P", "G", "PGS"))+
  labs(title= "PCR small intestine Day-1 Offspring", 
       x= "Group",
       y= "Relative mRNA levels (%)",
       colour= "Group")+ 
  theme(plot.title = element_text(hjust = 0.5), 
        strip.text.x = element_text(size = 12),
        strip.background = element_blank(),
        panel.spacing = unit(0.5, "cm"))
```

I finalment ho guardem, si veiem que surt algo tallat o massa apretat, podem fer la width o height més gran. Aquesta instrucció ens guardarà l'últim plot.

```{r,eval=FALSE}
ggsave(here("output","nom fitxer.png"), width = 18, height = 12, dpi = 300) 
```

### Afegir significància

En el cas de les meves dades no hi havia diferència entre grups així que vaig fer un gràfic amb el ΔCt (Ct(gene) - Ct(Gusb)) pr generacions. Ara ho farem tot amb un nou dataset, en el qual ja hauriem comprovat la normalitat i homogeneïtat (no ho compleix), i tindriem un kruskal-wallis tot significatiu. Per tant només indicaré el post-hoc, el gràfic, i com introduïr la significància.

```{r}
raw_data <- read_excel(here("Basic", "data", "PCR_ct.xlsx"))

data <- raw_data %>% 
  mutate(across(c(group, sex, rat, generation), as.factor)) 

longdata <- data %>% 
  pivot_longer(cols="gene_1":"gene_4", names_to="gene", values_to = "value" ) %>% 
  mutate(
      group = factor(group, 
                          levels = c("REF", "P", "G", "S", "PGS")), 
      generation = factor(generation, 
                          levels = c( "M", "Cd1", "Cd21", "CA")),
      gene = factor(gene,
                    levels = c("gene_1", "gene_2", "gene_3", "gene_4"))
                    )
```

Fem el post-hoc Dunn. Important que el nom de les columnes sigui igual al del dataset del gràfic (per exemple: gene).

```{r}
posthoc_dunn <- longdata %>%
  group_by(gene) %>%
  dunn_test(
    value ~ generation,
    p.adjust.method = "bonferroni")%>%
  add_significance("p.adj")

posthoc_dunn
```

Fem el gràfic

```{r}
generation_name <- c(M="Dams", Cd1= "Day-1 offspring", Cd21="Day-21 offspring", CA="Adult offspring")

ggplot <- longdata %>%
  na.omit() %>%
  ggplot(aes(x=generation, y=value, colour=generation))+ 
  geom_jitter(alpha = 0.5)+  #alpha mig transparent
  scale_x_discrete(limits = c("M", "Cd1", "Cd21", "CA"), #ordre dels eixos
                   expand = expansion(add = 1),
                   labels=c("D", "d1O", "d21O", "AO"))+ #com apareixeran
  facet_grid(~gene , 
             labeller = labeller(gene = gene_order))+
  geom_hline(yintercept = 0, color = "black",linetype = "dotted", linewidth = 0.5)+
  stat_summary(fun.data = mean_se, geom = "errorbar", width = 0.25) +
  stat_summary(fun = mean, geom = "crossbar", width = 0.75)+
  scale_colour_manual(values=c("#7B3FBF", "#87CEEB", "#4169E1", "#000080" ),
                      breaks = c("M", "Cd1", "Cd21", "CA"),
                      labels= generation_name)+ 
  labs(title= "PCR small intestine",
       x= "Generation", 
       y= "ΔCt (Ct(gene) - Ct(Gusb))", 
       colour= "Generation")+ 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 30, hjust = 1),
        strip.text.x = element_text(size = 12),
        strip.text.y = element_text(size = 12, hjust = 0.75), #intentar arreglar el hjust per posar l'etiqueta al 100
        strip.background = element_blank(),
        panel.spacing = unit(0.5, "cm")) #espai entre els mini gràfics

ggplot
```

Preparem els resultats del post-hoc perquè apareguin al gràfic.

```{r}
gen_levels <- c("M", "Cd1", "Cd21", "CA")

posthoc_graph <- posthoc_dunn %>% 
  add_xy_position (x= "generation") %>% 
  filter(p.adj < 0.05) %>%
  mutate(
    x1 = match(group1, gen_levels),
    x2 = match(group2, gen_levels),
    bracket_length = abs(x2 - x1)) %>% 
  group_by(gene) %>%
  arrange(bracket_length) %>%
  mutate(
    y.position = min(y.position, na.rm = TRUE) +
      seq(1, by = 1, length.out = n())) %>%
  ungroup()
```

-   `add_xy_position (x= "generation")` afegiex la posició x i y on ha de sortir

-   `filter(p.adj < 0.05)` que només apareguin les significatives

-   `mutate( x1 = match(group1, gen_levels), x2 = match(group2, gen_levels), bracket_length = abs(x2 - x1))` això ens permet seterminar quins seràn més llargs o més curts per a col·locar-los en ordre ascendent després amb l'`arrange(bracket_length)` i quedi més maco

-   `mutate( y.position = min(y.position, na.rm = TRUE) + seq(1, by = 1, length.out = n()))` modifiquem de manera manual per a que quedin consecutius al gràfic

Afegin la significació al gràfic que ja haviem creat.

```{r}
library(ggpubr)
ggplot + 
  stat_pvalue_manual(
  posthoc_graph,
  tip.length = 0.01,
  bracket.nudge.y = -1,   # pujar/baixar tots els brackets
  hide.ns = TRUE)
```

## Heatmap log~2~(FC)

Per a fer un heatmap amb augment o disminució de concentracions respecte al grup REF amb la significància, la qual tenim en una altre taula d'excel.

On ho vaig aprendre: <https://youtu.be/369PHkv1fPg?feature=shared>

En el cas de que tinguem els valors per cada observació, primer haurem de calcular el log~2~(FC) de les dades.

```{r, warning=FALSE, message=FALSE, eval=FALSE}

#Carregar els paquets bàsics -------
library(tidyverse)
library(here)
library(readxl)
library(janitor)
library(skimr)

#paquet extra: 
library(pheatmap)

#Importar dades i preprarar-les-------
raw_data <- read_excel(here("data", "PCR.xlsx")) 

data <- raw_data %>% 
  clean_names() %>%
  mutate(across(c(group, sex, rat, generation), as.factor)) 

skim(data)
```

Convertim les dades

A partir d'aquí s'ha de revisar

```{r, eval=FALSE}
data_log2<- data %>% 
  group_by(group) %>%
  mutate(across(
    where(is.numeric),
    ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)
  )) %>% 
  ungroup() %>% 
  mutate(across(
      3:last_col(),
      ~ .x / mean(.x [group == "REF"], na.rm = TRUE)
    )) %>% #canviem els NA per la mitjana d'aquell metabolit dins del grup
  mutate(across(3:last_col(), log2)) #aplicar logaritme

data_HM <- data_log2 %>%
  select(-group) %>%              # 1️⃣ eliminar columna group
  column_to_rownames("rat") %>%   # 2️⃣ rat → rownames
  t() %>%                         # 3️⃣ transposar
  as.data.frame()

mat_data <- data.matrix(data_HM) #fem una matriu
```

Espero que us hagi servit!
