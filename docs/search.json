[
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "Quarto",
    "section": "",
    "text": "Per a crear un document i que jo l’afegeixi a la web heu de crear un document Quarto.\nFile -&gt; New File -&gt; Quarto document…\n\nAfegiu com a títol el nom que voleu que tingui la pestanya a la web, i creeu sense canviar res més.\n\nGuardeu el document en format .qmd i ja podeu començar a crear.\n\n\n\nCom podeu veure la pestanya on normalment surten els scripts ha canviat una mica. Us recomano tenir-ho en mode Visual (enlloc de Source) per a facilitar-vos l’escriptura.\nSeguidament tenim el botó per posar en Negreta, Cursiva, o tipus Codi . Seguidament si volem afegir títols, llistes amb punt o numèriques. Després per afegir links o fotografies, altres formats, i el més important: INSERT. Quan vulguem afegir trossos de codi que s’executin (el que fa la web més interessant), serà insertar una executable cell de R\n\n\n#posar aquí les parts de l'script que t'interessin.\n\nA vegades però vols crear un codi però que només es mostri en aquest estil, que no s’executi. Dins del {r} inicial pots afegir paràmetres, tants com vulguis:\n\n{r, eval=FALSE} No s’executarà\n{r, warning=FALSE} No ensenyarà els warnings que et donaria R (per exemple que un paquet està emmascarat per un altre o fet amb una altre versió)\n{r, message=FALSE} No ensenyarà els missatges que mostraria R\n\nEl fitxer que s’està creant és html, que equival a un fitxer web. Tot i així, quan l’executeu només ho veureu vosaltres, res es penjarà al núvol. Recomano anar-lo executant (Render) cada cop que afegiu una cel·la executable. Si alguna part del codi està malament, no crearà la web, ho pararà. Per tant és molt més fàcil identificar els problemes un a un que no fer tota la web i que després no hi hagi manera d’executar-ho.\nQuan tingueu el fitxer fet me l’haureu d’enviar i jo el penjaré a la web que ja tinc creada. Si vulguèssiu fer la vostra pròpia web si que ja és més complicat.\nTambé heu de tenir en compte que les dades que pengi seràn públiques, per tant us recomano demanar-li a alguna intel·ligència artificial que us crei un dataset similar al vostre però sintètic, d’aquesta manera no es publicaràn dades sense publicar abans a un article. També me les haureu d’enviar amb el fitxer .qmd\nSi un dia us hi poseu ja veureu que és un moment i després us fareu la vida molt més fàcil quan vulgueu replicar algun assaig amb diferents dades o quan algú us demani un script que ja no enteneu ;)\n\n\n\nElsa això ja és per tu, com actualitzar la web quan t’enviin algo.\nPosar el fitxer .qmd a dins del projecte però no a cap subcarpeta. Afegir les dades al directori que indiqui l’script (i si no està amb el here() afegir-ho i canviar-ho).\nAl fitxer _quart.yml afegir el fitxer i com apareixerà. si ho han posat amb un nom complicat canviar-lo a tot minúscules i sense espais.\n\nQuan tot estigui correcte i no generi errors, al terminal afegir\n\nquarto render\ngit add .\ngit commit -m \"Actualització\"\ngit push\n\nComprovar al cap d’uns minuts si la web s’ha actualitzat."
  },
  {
    "objectID": "quarto.html#característiques-del-tipus-de-document",
    "href": "quarto.html#característiques-del-tipus-de-document",
    "title": "Quarto",
    "section": "",
    "text": "Com podeu veure la pestanya on normalment surten els scripts ha canviat una mica. Us recomano tenir-ho en mode Visual (enlloc de Source) per a facilitar-vos l’escriptura.\nSeguidament tenim el botó per posar en Negreta, Cursiva, o tipus Codi . Seguidament si volem afegir títols, llistes amb punt o numèriques. Després per afegir links o fotografies, altres formats, i el més important: INSERT. Quan vulguem afegir trossos de codi que s’executin (el que fa la web més interessant), serà insertar una executable cell de R\n\n\n#posar aquí les parts de l'script que t'interessin.\n\nA vegades però vols crear un codi però que només es mostri en aquest estil, que no s’executi. Dins del {r} inicial pots afegir paràmetres, tants com vulguis:\n\n{r, eval=FALSE} No s’executarà\n{r, warning=FALSE} No ensenyarà els warnings que et donaria R (per exemple que un paquet està emmascarat per un altre o fet amb una altre versió)\n{r, message=FALSE} No ensenyarà els missatges que mostraria R\n\nEl fitxer que s’està creant és html, que equival a un fitxer web. Tot i així, quan l’executeu només ho veureu vosaltres, res es penjarà al núvol. Recomano anar-lo executant (Render) cada cop que afegiu una cel·la executable. Si alguna part del codi està malament, no crearà la web, ho pararà. Per tant és molt més fàcil identificar els problemes un a un que no fer tota la web i que després no hi hagi manera d’executar-ho.\nQuan tingueu el fitxer fet me l’haureu d’enviar i jo el penjaré a la web que ja tinc creada. Si vulguèssiu fer la vostra pròpia web si que ja és més complicat.\nTambé heu de tenir en compte que les dades que pengi seràn públiques, per tant us recomano demanar-li a alguna intel·ligència artificial que us crei un dataset similar al vostre però sintètic, d’aquesta manera no es publicaràn dades sense publicar abans a un article. També me les haureu d’enviar amb el fitxer .qmd\nSi un dia us hi poseu ja veureu que és un moment i després us fareu la vida molt més fàcil quan vulgueu replicar algun assaig amb diferents dades o quan algú us demani un script que ja no enteneu ;)"
  },
  {
    "objectID": "quarto.html#per-actualitzar-la-web",
    "href": "quarto.html#per-actualitzar-la-web",
    "title": "Quarto",
    "section": "",
    "text": "Elsa això ja és per tu, com actualitzar la web quan t’enviin algo.\nPosar el fitxer .qmd a dins del projecte però no a cap subcarpeta. Afegir les dades al directori que indiqui l’script (i si no està amb el here() afegir-ho i canviar-ho).\nAl fitxer _quart.yml afegir el fitxer i com apareixerà. si ho han posat amb un nom complicat canviar-lo a tot minúscules i sense espais.\n\nQuan tot estigui correcte i no generi errors, al terminal afegir\n\nquarto render\ngit add .\ngit commit -m \"Actualització\"\ngit push\n\nComprovar al cap d’uns minuts si la web s’ha actualitzat."
  },
  {
    "objectID": "grafics.html",
    "href": "grafics.html",
    "title": "Gràfics",
    "section": "",
    "text": "Les dades amb les que treballarem, segurament ja ho heu fet.\n\nlibrary(tidyverse) \nlibrary(here) \nlibrary(readxl) \nlibrary(janitor) \nlibrary(skimr) \nlibrary(broom) \nlibrary(rstatix) \n\nraw_data &lt;- read_excel(here(\"Basic\", \"data\", \"PCR.xlsx\"),  sheet = \"relative\")\n\ndata &lt;- raw_data %&gt;% \n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\"))\n                    )\n\nPer a fer gràfics R ja et dona opcions per defecte, però per a triar i personalitzar certs aspectes és millor fer-ho amb ggplot (inclòs a tidyverse). Recomano molt tenir la Cheatsheet de ggplot2 impresa per anar consultant les ocpions.\n\n\nPer a graficar les dades de PCR, farem un núvol de punts amb línia a la mitjana i barres d’error.\nComencem fent tot el que ja hem explicat\n\n#Carregar els paquets bàsics -------\nlibrary(tidyverse)\nlibrary(here)\nlibrary(readxl)\nlibrary(janitor)\nlibrary(skimr)\n\n#Importar dades i preprarar-les-------\nraw_data &lt;- read_excel(here(\"data\", \"PCR.xlsx\")) \n\n#crear dataset amb el que treballarem\ndata &lt;- raw_data %&gt;% \n  clean_names() %&gt;%\n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nskim(data) \n\n#creem long data\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\")))\n\nSeguidament podem fer un gràfic previ per veure com es comporten els gens en general, sense separar per generació.\n\nlongdata %&gt;%\n  na.omit() %&gt;% \n  group_by(generation) %&gt;% \n  ggplot(aes(x=group, y=value, colour=generation))+ \n    geom_jitter(position = position_dodge(width = 0.6))+ \n    scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"))+ \n    facet_wrap(~gene) \n\n\n\n\n\n\n\n\nCom podeu veure abans de fer el gràfic hem preparat les dades en la mateixa pipeline, ometent els NA i agrupant per generacions. Seguidament li hem demanat al gràfic:\n\nggplot(aes(x=group, y=value, colour=generation))+ quin és l’eix de les x, quin és l’eix de les y i que determina el color\ngeom_jitter(position = position_dodge(width = 0.6))+ fer un gràfic de punts amb els valors espaiats\nscale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"))+ l’ordre en que apareixen els grups a l’eix de les x\nfacet_wrap(~gene) indica que ho separi en mini gràfics, un per cada gen. També podriem fer servir facet_grid(~) per a separar-ho de manera més controlada, ho veurem al següent.\n\nDefinim el tema i els colors del grup:\n\n#canviar estil del gràfic default\ntheme_set(theme_classic()) \n\n#definim els colors que volem per grup\ncolors &lt;- c(\"REF\" = \"#999999\",   # Grey\n            \"PGS\" = \"#1b9e77\",   # Green 1\n            \"S\" = \"#66a61e\",   # Green 2\n            \"G\" = \"#a6d854\",   # Green 3\n            \"P\" = \"#d9f0a3\")   # Green 4\n\nAnem a personalitzar-lo més i afegir les barres d’error i mitjana. Hi ha dues maneres de fer-ho, la primera és com ho feia inicialment però són més passos innecessaris, tot i que es controla més.\nPrimer canviem l’ordre en el que apareixeran els gens i el nom del grup de la generació per a que ens surti complet.\n\n#reordenar com sortiran els gens com interessi\ngene_order &lt;- c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\")\nlongdata$gene &lt;- factor(longdata$gene, levels = gene_order)\n\n#com volem que surti el nom de la generació\ngeneration_name &lt;- c(\n      M   = \"Dams\",\n      Cd1 = \"Day-1 offspring\",\n      Cd21= \"Day-21 offspring\",\n      CA  = \"Adult offspring\"\n    )\n\n\nAbans de res hem de crear un dataset que contingui la mitjana i error estàndard de cada grup per cada gen dins de cada generació.\n\n\n# Compute summary stats per a afegir al gràfic-------\nsummary_data &lt;- longdata %&gt;%\n  na.omit() %&gt;%\n  group_by(generation, gene, group) %&gt;% \n  summarise(\n    mean = mean(value), #calculem mitjana\n    se = sd(value)/sqrt(n()), #calculem error estàndard\n    .groups = \"drop\" \n  )\n\nsummary_data$gene &lt;- factor(summary_data$gene, levels = gene_order)\n\nJa podem fer el gràfic\n\n#GRÀFIC BO TOTALS------\nggplot &lt;- longdata %&gt;% #dataset a graficar en format \"long\"\n  na.omit() %&gt;% #no tenir en compte els NA\n  ggplot(aes(x=group, y=value, colour=group))+ \n  geom_jitter()+ #gràfic punts\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"), \n                   expand = expansion(add = 1))+ #afegir espai entre grups\n  facet_grid(generation~gene, \n             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre \n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  geom_errorbar(data = summary_data, \n                aes(x = group, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+ #afegir barres d'error\n  geom_errorbar( #afegir línia mitjana\n    data = summary_data,\n    aes(x = group,\n        ymin = mean,\n        ymax = mean,\n        colour = group),\n    width = 0.8,\n    inherit.aes = FALSE,\n    linewidth = 1)+ \n  scale_colour_manual(values=colors, \n                      breaks = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\"))+ \n  labs(title= \"PCR small intestine\", \n       x= \"Group\", \n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+  \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\n\ngeom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", size = 0.5)+ Afegim una línia de punts al 100\ngeom_errorbar(data = summary_data, aes(x = group_name, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+ Afegim les barres d’error\ngeom_errorbar(data = summary_data, aes( x = group, ymin = mean, ymax = mean, colour = group), width = 0.8, inherit.aes = FALSE, linewidth = 1 )+ Afegim línia a la mitjana.\nlabs(title= \"PCR small intestine\", gràfic x= \"Group\",  eix x y= \"Relative mRNA levels (%)\", colour= \"Group\")+ Et permet canviar el nom dels eixos i títol i nom de la llegenda, en aquest cas ens la fa del color però també la podria fer per colour, fill, shape, linetype, size…\n\n\nSense necessitat de fer un altre dataset amb les mitjanes, enlloc de geom_errorbar(data = summary_data , posem stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5)per la barra d’error i stat_summary(fun = mean, geom = \"crossbar\", width = 0.75) per la mitjana. D’aquesta manera ja ho calcula ell i no hem de tenir dos datasets\n\n\nggplot &lt;- longdata %&gt;% #dataset a graficar en format \"long\"\n  na.omit() %&gt;% #no tenir en compte els NA\n  ggplot(aes(x=group, y=value, colour=group))+ \n  geom_jitter()+ #gràfic punts\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"), \n                   expand = expansion(add = 1))+ #afegir espai entre grups\n  facet_grid(generation~gene, \n             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre \n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=colors, \n                      breaks = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\"))+ \n  labs(title= \"PCR small intestine\", \n       x= \"Group\", \n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+  \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\nUn altre exemple seria triar només una generació, on només canvia el següent\n\nlongdata %&gt;%\n  na.omit() %&gt;% \n  filter(generation==\"Cd1\") %&gt;% #afegim filtre!!\n  ggplot(aes(x=group, y=value, colour=group))+\n  geom_jitter()+\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\",\"PGS\"),\n                   expand = expansion(add = 1))+\n  facet_grid(~gene,    #només separem per gen\n             labeller = labeller(gene = gene_order))+\n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", size = 0.5)+ \n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=colors,\n                breaks = c(\"REF\", \"P\", \"G\", \"PGS\"))+\n  labs(title= \"PCR small intestine Day-1 Offspring\", \n       x= \"Group\",\n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+ \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\"))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nI finalment ho guardem, si veiem que surt algo tallat o massa apretat, podem fer la width o height més gran. Aquesta instrucció ens guardarà l’últim plot.\n\nggsave(here(\"output\",\"nom fitxer.png\"), width = 18, height = 12, dpi = 300) \n\n\n\nEn el cas de les meves dades no hi havia diferència entre grups així que vaig fer un gràfic amb el ΔCt (Ct(gene) - Ct(Gusb)) pr generacions. Ara ho farem tot amb un nou dataset, en el qual ja hauriem comprovat la normalitat i homogeneïtat (no ho compleix), i tindriem un kruskal-wallis tot significatiu. Per tant només indicaré el post-hoc, el gràfic, i com introduïr la significància.\n\nraw_data &lt;- read_excel(here(\"Basic\", \"data\", \"PCR_ct.xlsx\"))\n\ndata &lt;- raw_data %&gt;% \n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\"))\n                    )\n\nFem el post-hoc Dunn. Important que el nom de les columnes sigui igual al del dataset del gràfic (per exemple: gene).\n\nposthoc_dunn &lt;- longdata %&gt;%\n  group_by(gene) %&gt;%\n  dunn_test(\n    value ~ generation,\n    p.adjust.method = \"bonferroni\")%&gt;%\n  add_significance(\"p.adj\")\n\nposthoc_dunn\n\n# A tibble: 24 × 10\n   gene   .y.   group1 group2    n1    n2 statistic        p    p.adj\n   &lt;fct&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 gene_1 value M      Cd1       25    40      3.17 1.51e- 3 9.07e- 3\n 2 gene_1 value M      Cd21      25    50     -3.72 2.01e- 4 1.21e- 3\n 3 gene_1 value M      CA        25    20      4.30 1.69e- 5 1.01e- 4\n 4 gene_1 value Cd1    Cd21      40    50     -8.11 5.25e-16 3.15e-15\n 5 gene_1 value Cd1    CA        40    20      1.76 7.85e- 2 4.71e- 1\n 6 gene_1 value Cd21   CA        50    20      8.32 8.77e-17 5.26e-16\n 7 gene_2 value M      Cd1       25    40      3.98 6.87e- 5 4.12e- 4\n 8 gene_2 value M      Cd21      25    50     -3.02 2.53e- 3 1.52e- 2\n 9 gene_2 value M      CA        25    20      4.72 2.31e- 6 1.39e- 5\n10 gene_2 value Cd1    Cd21      40    50     -8.27 1.33e-16 7.96e-16\n# ℹ 14 more rows\n# ℹ 1 more variable: p.adj.signif &lt;chr&gt;\n\n\nFem el gràfic\n\ngeneration_name &lt;- c(M=\"Dams\", Cd1= \"Day-1 offspring\", Cd21=\"Day-21 offspring\", CA=\"Adult offspring\")\n\nggplot &lt;- longdata %&gt;%\n  na.omit() %&gt;%\n  ggplot(aes(x=generation, y=value, colour=generation))+ \n  geom_jitter(alpha = 0.5)+  #alpha mig transparent\n  scale_x_discrete(limits = c(\"M\", \"Cd1\", \"Cd21\", \"CA\"), #ordre dels eixos\n                   expand = expansion(add = 1),\n                   labels=c(\"D\", \"d1O\", \"d21O\", \"AO\"))+ #com apareixeran\n  facet_grid(~gene , \n             labeller = labeller(gene = gene_order))+\n  geom_hline(yintercept = 0, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.25) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=c(\"#7B3FBF\", \"#87CEEB\", \"#4169E1\", \"#000080\" ),\n                      breaks = c(\"M\", \"Cd1\", \"Cd21\", \"CA\"),\n                      labels= generation_name)+ \n  labs(title= \"PCR small intestine\",\n       x= \"Generation\", \n       y= \"ΔCt (Ct(gene) - Ct(Gusb))\", \n       colour= \"Generation\")+ \n  theme(plot.title = element_text(hjust = 0.5), \n        axis.text.x = element_text(angle = 30, hjust = 1),\n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75), #intentar arreglar el hjust per posar l'etiqueta al 100\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\nPreparem els resultats del post-hoc perquè apareguin al gràfic.\n\ngen_levels &lt;- c(\"M\", \"Cd1\", \"Cd21\", \"CA\")\n\nposthoc_graph &lt;- posthoc_dunn %&gt;% \n  add_xy_position (x= \"generation\") %&gt;% \n  filter(p.adj &lt; 0.05) %&gt;%\n  mutate(\n    x1 = match(group1, gen_levels),\n    x2 = match(group2, gen_levels),\n    bracket_length = abs(x2 - x1)) %&gt;% \n  group_by(gene) %&gt;%\n  arrange(bracket_length) %&gt;%\n  mutate(\n    y.position = min(y.position, na.rm = TRUE) +\n      seq(1, by = 1, length.out = n())) %&gt;%\n  ungroup()\n\n\nadd_xy_position (x= \"generation\") afegiex la posició x i y on ha de sortir\nfilter(p.adj &lt; 0.05) que només apareguin les significatives\nmutate( x1 = match(group1, gen_levels), x2 = match(group2, gen_levels), bracket_length = abs(x2 - x1)) això ens permet seterminar quins seràn més llargs o més curts per a col·locar-los en ordre ascendent després amb l’arrange(bracket_length) i quedi més maco\nmutate( y.position = min(y.position, na.rm = TRUE) + seq(1, by = 1, length.out = n())) modifiquem de manera manual per a que quedin consecutius al gràfic\n\nAfegin la significació al gràfic que ja haviem creat.\n\nlibrary(ggpubr)\nggplot + \n  stat_pvalue_manual(\n  posthoc_graph,\n  tip.length = 0.01,\n  bracket.nudge.y = -1,   # pujar/baixar tots els brackets\n  hide.ns = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nPer a fer un heatmap amb augment o disminució de concentracions respecte al grup REF amb la significància, la qual tenim en una altre taula d’excel.\nOn ho vaig aprendre: https://youtu.be/369PHkv1fPg?feature=shared\nEn el cas de que tinguem els valors per cada observació, primer haurem de calcular el log2(FC) de les dades.\n\n#Carregar els paquets bàsics -------\nlibrary(tidyverse)\nlibrary(here)\nlibrary(readxl)\nlibrary(janitor)\nlibrary(skimr)\n\n#paquet extra: \nlibrary(pheatmap)\n\n#Importar dades i preprarar-les-------\nraw_data &lt;- read_excel(here(\"data\", \"PCR.xlsx\")) \n\ndata &lt;- raw_data %&gt;% \n  clean_names() %&gt;%\n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nskim(data)\n\nConvertim les dades\nA partir d’aquí s’ha de revisar\n\ndata_log2&lt;- data %&gt;% \n  group_by(group) %&gt;%\n  mutate(across(\n    where(is.numeric),\n    ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)\n  )) %&gt;% \n  ungroup() %&gt;% \n  mutate(across(\n      3:last_col(),\n      ~ .x / mean(.x [group == \"REF\"], na.rm = TRUE)\n    )) %&gt;% #canviem els NA per la mitjana d'aquell metabolit dins del grup\n  mutate(across(3:last_col(), log2)) #aplicar logaritme\n\ndata_HM &lt;- data_log2 %&gt;%\n  select(-group) %&gt;%              # 1️⃣ eliminar columna group\n  column_to_rownames(\"rat\") %&gt;%   # 2️⃣ rat → rownames\n  t() %&gt;%                         # 3️⃣ transposar\n  as.data.frame()\n\nmat_data &lt;- data.matrix(data_HM) #fem una matriu\n\nEspero que us hagi servit!"
  },
  {
    "objectID": "grafics.html#pcr",
    "href": "grafics.html#pcr",
    "title": "Gràfics",
    "section": "",
    "text": "Per a graficar les dades de PCR, farem un núvol de punts amb línia a la mitjana i barres d’error.\nComencem fent tot el que ja hem explicat\n\n#Carregar els paquets bàsics -------\nlibrary(tidyverse)\nlibrary(here)\nlibrary(readxl)\nlibrary(janitor)\nlibrary(skimr)\n\n#Importar dades i preprarar-les-------\nraw_data &lt;- read_excel(here(\"data\", \"PCR.xlsx\")) \n\n#crear dataset amb el que treballarem\ndata &lt;- raw_data %&gt;% \n  clean_names() %&gt;%\n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nskim(data) \n\n#creem long data\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\")))\n\nSeguidament podem fer un gràfic previ per veure com es comporten els gens en general, sense separar per generació.\n\nlongdata %&gt;%\n  na.omit() %&gt;% \n  group_by(generation) %&gt;% \n  ggplot(aes(x=group, y=value, colour=generation))+ \n    geom_jitter(position = position_dodge(width = 0.6))+ \n    scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"))+ \n    facet_wrap(~gene) \n\n\n\n\n\n\n\n\nCom podeu veure abans de fer el gràfic hem preparat les dades en la mateixa pipeline, ometent els NA i agrupant per generacions. Seguidament li hem demanat al gràfic:\n\nggplot(aes(x=group, y=value, colour=generation))+ quin és l’eix de les x, quin és l’eix de les y i que determina el color\ngeom_jitter(position = position_dodge(width = 0.6))+ fer un gràfic de punts amb els valors espaiats\nscale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"))+ l’ordre en que apareixen els grups a l’eix de les x\nfacet_wrap(~gene) indica que ho separi en mini gràfics, un per cada gen. També podriem fer servir facet_grid(~) per a separar-ho de manera més controlada, ho veurem al següent.\n\nDefinim el tema i els colors del grup:\n\n#canviar estil del gràfic default\ntheme_set(theme_classic()) \n\n#definim els colors que volem per grup\ncolors &lt;- c(\"REF\" = \"#999999\",   # Grey\n            \"PGS\" = \"#1b9e77\",   # Green 1\n            \"S\" = \"#66a61e\",   # Green 2\n            \"G\" = \"#a6d854\",   # Green 3\n            \"P\" = \"#d9f0a3\")   # Green 4\n\nAnem a personalitzar-lo més i afegir les barres d’error i mitjana. Hi ha dues maneres de fer-ho, la primera és com ho feia inicialment però són més passos innecessaris, tot i que es controla més.\nPrimer canviem l’ordre en el que apareixeran els gens i el nom del grup de la generació per a que ens surti complet.\n\n#reordenar com sortiran els gens com interessi\ngene_order &lt;- c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\")\nlongdata$gene &lt;- factor(longdata$gene, levels = gene_order)\n\n#com volem que surti el nom de la generació\ngeneration_name &lt;- c(\n      M   = \"Dams\",\n      Cd1 = \"Day-1 offspring\",\n      Cd21= \"Day-21 offspring\",\n      CA  = \"Adult offspring\"\n    )\n\n\nAbans de res hem de crear un dataset que contingui la mitjana i error estàndard de cada grup per cada gen dins de cada generació.\n\n\n# Compute summary stats per a afegir al gràfic-------\nsummary_data &lt;- longdata %&gt;%\n  na.omit() %&gt;%\n  group_by(generation, gene, group) %&gt;% \n  summarise(\n    mean = mean(value), #calculem mitjana\n    se = sd(value)/sqrt(n()), #calculem error estàndard\n    .groups = \"drop\" \n  )\n\nsummary_data$gene &lt;- factor(summary_data$gene, levels = gene_order)\n\nJa podem fer el gràfic\n\n#GRÀFIC BO TOTALS------\nggplot &lt;- longdata %&gt;% #dataset a graficar en format \"long\"\n  na.omit() %&gt;% #no tenir en compte els NA\n  ggplot(aes(x=group, y=value, colour=group))+ \n  geom_jitter()+ #gràfic punts\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"), \n                   expand = expansion(add = 1))+ #afegir espai entre grups\n  facet_grid(generation~gene, \n             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre \n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  geom_errorbar(data = summary_data, \n                aes(x = group, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+ #afegir barres d'error\n  geom_errorbar( #afegir línia mitjana\n    data = summary_data,\n    aes(x = group,\n        ymin = mean,\n        ymax = mean,\n        colour = group),\n    width = 0.8,\n    inherit.aes = FALSE,\n    linewidth = 1)+ \n  scale_colour_manual(values=colors, \n                      breaks = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\"))+ \n  labs(title= \"PCR small intestine\", \n       x= \"Group\", \n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+  \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\n\ngeom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", size = 0.5)+ Afegim una línia de punts al 100\ngeom_errorbar(data = summary_data, aes(x = group_name, y = mean, ymin = mean - se, ymax = mean + se, width = 0.25))+ Afegim les barres d’error\ngeom_errorbar(data = summary_data, aes( x = group, ymin = mean, ymax = mean, colour = group), width = 0.8, inherit.aes = FALSE, linewidth = 1 )+ Afegim línia a la mitjana.\nlabs(title= \"PCR small intestine\", gràfic x= \"Group\",  eix x y= \"Relative mRNA levels (%)\", colour= \"Group\")+ Et permet canviar el nom dels eixos i títol i nom de la llegenda, en aquest cas ens la fa del color però també la podria fer per colour, fill, shape, linetype, size…\n\n\nSense necessitat de fer un altre dataset amb les mitjanes, enlloc de geom_errorbar(data = summary_data , posem stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5)per la barra d’error i stat_summary(fun = mean, geom = \"crossbar\", width = 0.75) per la mitjana. D’aquesta manera ja ho calcula ell i no hem de tenir dos datasets\n\n\nggplot &lt;- longdata %&gt;% #dataset a graficar en format \"long\"\n  na.omit() %&gt;% #no tenir en compte els NA\n  ggplot(aes(x=group, y=value, colour=group))+ \n  geom_jitter()+ #gràfic punts\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\", \"S\",\"PGS\"), \n                   expand = expansion(add = 1))+ #afegir espai entre grups\n  facet_grid(generation~gene, \n             labeller = labeller(gene = gene_order, generation = generation_name))+ #ordre \n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=colors, \n                      breaks = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\"))+ \n  labs(title= \"PCR small intestine\", \n       x= \"Group\", \n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+  \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\nUn altre exemple seria triar només una generació, on només canvia el següent\n\nlongdata %&gt;%\n  na.omit() %&gt;% \n  filter(generation==\"Cd1\") %&gt;% #afegim filtre!!\n  ggplot(aes(x=group, y=value, colour=group))+\n  geom_jitter()+\n  scale_x_discrete(limits = c(\"REF\", \"P\", \"G\",\"PGS\"),\n                   expand = expansion(add = 1))+\n  facet_grid(~gene,    #només separem per gen\n             labeller = labeller(gene = gene_order))+\n  geom_hline(yintercept = 100, color = \"black\",linetype = \"dotted\", size = 0.5)+ \n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.5) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=colors,\n                breaks = c(\"REF\", \"P\", \"G\", \"PGS\"))+\n  labs(title= \"PCR small intestine Day-1 Offspring\", \n       x= \"Group\",\n       y= \"Relative mRNA levels (%)\",\n       colour= \"Group\")+ \n  theme(plot.title = element_text(hjust = 0.5), \n        strip.text.x = element_text(size = 12),\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\"))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\nI finalment ho guardem, si veiem que surt algo tallat o massa apretat, podem fer la width o height més gran. Aquesta instrucció ens guardarà l’últim plot.\n\nggsave(here(\"output\",\"nom fitxer.png\"), width = 18, height = 12, dpi = 300) \n\n\n\nEn el cas de les meves dades no hi havia diferència entre grups així que vaig fer un gràfic amb el ΔCt (Ct(gene) - Ct(Gusb)) pr generacions. Ara ho farem tot amb un nou dataset, en el qual ja hauriem comprovat la normalitat i homogeneïtat (no ho compleix), i tindriem un kruskal-wallis tot significatiu. Per tant només indicaré el post-hoc, el gràfic, i com introduïr la significància.\n\nraw_data &lt;- read_excel(here(\"Basic\", \"data\", \"PCR_ct.xlsx\"))\n\ndata &lt;- raw_data %&gt;% \n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\"))\n                    )\n\nFem el post-hoc Dunn. Important que el nom de les columnes sigui igual al del dataset del gràfic (per exemple: gene).\n\nposthoc_dunn &lt;- longdata %&gt;%\n  group_by(gene) %&gt;%\n  dunn_test(\n    value ~ generation,\n    p.adjust.method = \"bonferroni\")%&gt;%\n  add_significance(\"p.adj\")\n\nposthoc_dunn\n\n# A tibble: 24 × 10\n   gene   .y.   group1 group2    n1    n2 statistic        p    p.adj\n   &lt;fct&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 gene_1 value M      Cd1       25    40      3.17 1.51e- 3 9.07e- 3\n 2 gene_1 value M      Cd21      25    50     -3.72 2.01e- 4 1.21e- 3\n 3 gene_1 value M      CA        25    20      4.30 1.69e- 5 1.01e- 4\n 4 gene_1 value Cd1    Cd21      40    50     -8.11 5.25e-16 3.15e-15\n 5 gene_1 value Cd1    CA        40    20      1.76 7.85e- 2 4.71e- 1\n 6 gene_1 value Cd21   CA        50    20      8.32 8.77e-17 5.26e-16\n 7 gene_2 value M      Cd1       25    40      3.98 6.87e- 5 4.12e- 4\n 8 gene_2 value M      Cd21      25    50     -3.02 2.53e- 3 1.52e- 2\n 9 gene_2 value M      CA        25    20      4.72 2.31e- 6 1.39e- 5\n10 gene_2 value Cd1    Cd21      40    50     -8.27 1.33e-16 7.96e-16\n# ℹ 14 more rows\n# ℹ 1 more variable: p.adj.signif &lt;chr&gt;\n\n\nFem el gràfic\n\ngeneration_name &lt;- c(M=\"Dams\", Cd1= \"Day-1 offspring\", Cd21=\"Day-21 offspring\", CA=\"Adult offspring\")\n\nggplot &lt;- longdata %&gt;%\n  na.omit() %&gt;%\n  ggplot(aes(x=generation, y=value, colour=generation))+ \n  geom_jitter(alpha = 0.5)+  #alpha mig transparent\n  scale_x_discrete(limits = c(\"M\", \"Cd1\", \"Cd21\", \"CA\"), #ordre dels eixos\n                   expand = expansion(add = 1),\n                   labels=c(\"D\", \"d1O\", \"d21O\", \"AO\"))+ #com apareixeran\n  facet_grid(~gene , \n             labeller = labeller(gene = gene_order))+\n  geom_hline(yintercept = 0, color = \"black\",linetype = \"dotted\", linewidth = 0.5)+\n  stat_summary(fun.data = mean_se, geom = \"errorbar\", width = 0.25) +\n  stat_summary(fun = mean, geom = \"crossbar\", width = 0.75)+\n  scale_colour_manual(values=c(\"#7B3FBF\", \"#87CEEB\", \"#4169E1\", \"#000080\" ),\n                      breaks = c(\"M\", \"Cd1\", \"Cd21\", \"CA\"),\n                      labels= generation_name)+ \n  labs(title= \"PCR small intestine\",\n       x= \"Generation\", \n       y= \"ΔCt (Ct(gene) - Ct(Gusb))\", \n       colour= \"Generation\")+ \n  theme(plot.title = element_text(hjust = 0.5), \n        axis.text.x = element_text(angle = 30, hjust = 1),\n        strip.text.x = element_text(size = 12),\n        strip.text.y = element_text(size = 12, hjust = 0.75), #intentar arreglar el hjust per posar l'etiqueta al 100\n        strip.background = element_blank(),\n        panel.spacing = unit(0.5, \"cm\")) #espai entre els mini gràfics\n\nggplot\n\n\n\n\n\n\n\n\nPreparem els resultats del post-hoc perquè apareguin al gràfic.\n\ngen_levels &lt;- c(\"M\", \"Cd1\", \"Cd21\", \"CA\")\n\nposthoc_graph &lt;- posthoc_dunn %&gt;% \n  add_xy_position (x= \"generation\") %&gt;% \n  filter(p.adj &lt; 0.05) %&gt;%\n  mutate(\n    x1 = match(group1, gen_levels),\n    x2 = match(group2, gen_levels),\n    bracket_length = abs(x2 - x1)) %&gt;% \n  group_by(gene) %&gt;%\n  arrange(bracket_length) %&gt;%\n  mutate(\n    y.position = min(y.position, na.rm = TRUE) +\n      seq(1, by = 1, length.out = n())) %&gt;%\n  ungroup()\n\n\nadd_xy_position (x= \"generation\") afegiex la posició x i y on ha de sortir\nfilter(p.adj &lt; 0.05) que només apareguin les significatives\nmutate( x1 = match(group1, gen_levels), x2 = match(group2, gen_levels), bracket_length = abs(x2 - x1)) això ens permet seterminar quins seràn més llargs o més curts per a col·locar-los en ordre ascendent després amb l’arrange(bracket_length) i quedi més maco\nmutate( y.position = min(y.position, na.rm = TRUE) + seq(1, by = 1, length.out = n())) modifiquem de manera manual per a que quedin consecutius al gràfic\n\nAfegin la significació al gràfic que ja haviem creat.\n\nlibrary(ggpubr)\nggplot + \n  stat_pvalue_manual(\n  posthoc_graph,\n  tip.length = 0.01,\n  bracket.nudge.y = -1,   # pujar/baixar tots els brackets\n  hide.ns = TRUE)"
  },
  {
    "objectID": "grafics.html#heatmap-log2fc",
    "href": "grafics.html#heatmap-log2fc",
    "title": "Gràfics",
    "section": "",
    "text": "Per a fer un heatmap amb augment o disminució de concentracions respecte al grup REF amb la significància, la qual tenim en una altre taula d’excel.\nOn ho vaig aprendre: https://youtu.be/369PHkv1fPg?feature=shared\nEn el cas de que tinguem els valors per cada observació, primer haurem de calcular el log2(FC) de les dades.\n\n#Carregar els paquets bàsics -------\nlibrary(tidyverse)\nlibrary(here)\nlibrary(readxl)\nlibrary(janitor)\nlibrary(skimr)\n\n#paquet extra: \nlibrary(pheatmap)\n\n#Importar dades i preprarar-les-------\nraw_data &lt;- read_excel(here(\"data\", \"PCR.xlsx\")) \n\ndata &lt;- raw_data %&gt;% \n  clean_names() %&gt;%\n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nskim(data)\n\nConvertim les dades\nA partir d’aquí s’ha de revisar\n\ndata_log2&lt;- data %&gt;% \n  group_by(group) %&gt;%\n  mutate(across(\n    where(is.numeric),\n    ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)\n  )) %&gt;% \n  ungroup() %&gt;% \n  mutate(across(\n      3:last_col(),\n      ~ .x / mean(.x [group == \"REF\"], na.rm = TRUE)\n    )) %&gt;% #canviem els NA per la mitjana d'aquell metabolit dins del grup\n  mutate(across(3:last_col(), log2)) #aplicar logaritme\n\ndata_HM &lt;- data_log2 %&gt;%\n  select(-group) %&gt;%              # 1️⃣ eliminar columna group\n  column_to_rownames(\"rat\") %&gt;%   # 2️⃣ rat → rownames\n  t() %&gt;%                         # 3️⃣ transposar\n  as.data.frame()\n\nmat_data &lt;- data.matrix(data_HM) #fem una matriu\n\nEspero que us hagi servit!"
  },
  {
    "objectID": "estadistica.html",
    "href": "estadistica.html",
    "title": "Estadística",
    "section": "",
    "text": "Les dades amb les que treballarem, segurament ja ho heu fet.\n\nlibrary(tidyverse) \nlibrary(here) \nlibrary(readxl) \nlibrary(janitor) \nlibrary(skimr) \nlibrary(broom) \nlibrary(rstatix) \n\nraw_data &lt;- read_excel(here(\"Basic\", \"data\", \"PCR.xlsx\"),  sheet = \"relative\")\n\ndata &lt;- raw_data %&gt;% \n  mutate(across(c(group, sex, rat, generation), as.factor)) \n\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\"))\n                    )\n\nLa majoria de l’estadística descriptiva ja la mirem amb l’excel, però per comprovar que tot ho estem fent igual, podem demanar una taula amb la mitjana, la sd, l’error, la n i els límits.\n\ntotal_results &lt;- longdata %&gt;%   #longdata!,wide data també es podria, no recomano\n    group_by(generation, group, gene) %&gt;% #que ho faci tot dins de la mateixa                                               generació i mateix grup i per cada gen\n    summarise(\n        across(\n           where(is.numeric),\n          list(\n            n = ~sum(!is.na(.x)),\n            mean = ~mean(.x, na.rm = TRUE), \n            sd = ~sd(.x, na.rm = TRUE),\n        error = ~sd(.x, na.rm = TRUE) / sqrt(sum(!is.na(.x))),\n          upper = ~mean(.x, na.rm = TRUE) + 2 * sd(.x, na.rm = TRUE),\n          lower = ~mean(.x, na.rm = TRUE) - 2 * sd(.x, na.rm = TRUE)\n          ),\n          .names = \"{.col}_{.fn}\"\n       )) %&gt;%\n          as.data.frame() #ensenyar-ho com a dataframe\n\n`summarise()` has grouped output by 'generation', 'group'. You can override\nusing the `.groups` argument.\n\nView(total_results)\nhead(total_results)\n\n  generation group   gene value_n value_mean  value_sd value_error value_upper\n1          M   REF gene_1       6  103.45000  6.919754    2.824978    117.2895\n2          M   REF gene_2       6   99.63333 11.881863    4.850750    123.3971\n3          M   REF gene_3       5   95.66000  8.143893    3.642060    111.9478\n4          M   REF gene_4       5   97.78000  8.799261    3.935149    115.3785\n5          M     P gene_1       5  129.72000  9.279925    4.150108    148.2798\n6          M     P gene_2       5  128.08000 15.767910    7.051624    159.6158\n  value_lower\n1    89.61049\n2    75.86961\n3    79.37221\n4    80.18148\n5   111.16015\n6    96.54418\n\n\nAl tenir activat na.rm=TRUE s’eliminen els NA del que estàs calculant."
  },
  {
    "objectID": "estadistica.html#normalitat",
    "href": "estadistica.html#normalitat",
    "title": "Estadística",
    "section": "Normalitat",
    "text": "Normalitat\nEn el cas que la el número de grups diferents sigui de n&lt;50 s’ha de fer Shapiro-Wilk. En el cas que la n&gt;50, Kolmogorov-Smirnov, el qual no explicaré ja que no l’hem de fer pràcticament mai.\nPer a la normalitat primer es comprova amb un QQplot, de manera visual\n\nQQplot &lt;- longdata %&gt;% \n  group_by(generation, group, gene) %&gt;% #com separaras a l'anàlisi posterior\n  ggplot(aes(sample = value)) +\n  stat_qq() +\n  stat_qq_line() +\n  facet_grid(generation + group ~ gene, scales = \"free\") +\n  theme_minimal() +\n  labs(title = \"QQ plots of value by generation, group and gene\",\n       y = \"Sample Quantiles\",\n       x = \"Theoretical Quantiles\")\n\nQQplot\n\n\n\n\n\n\n\n\nEn el cas de voler només una generació canviar el group_by(generation) per filter(generation == \"CA\").\nCom que no som experts en estadística, nosaltres també farem el test de Shapiro-Wilk per a que ens digui si són normals (p&gt;0.05) o no són normals (p&lt;0.05)\n\nshapiro_by_group &lt;- longdata %&gt;%\n  group_by(generation, group, gene) %&gt;%\n  summarise(\n    # SPSS-style df = size of the sample used\n    df = sum(!is.na(value)),\n    \n    # Shapiro–Wilk test (only runs if df ≥ 3, same as SPSS)\n    W = if(df &gt;= 3) shapiro.test(value)$statistic else NA_real_,\n    p_value = if(df &gt;= 3) shapiro.test(value)$p.value else NA_real_,\n    \n    .groups = \"drop\"\n  )%&gt;%\n  mutate(                  #per afegir columna de * significació, es pot treure\n    signif = case_when(\n      is.na(p_value)        ~ \"ns\",\n      p_value &lt; 0.001       ~ \"***\",\n      p_value &lt; 0.01        ~ \"**\",\n      p_value &lt; 0.05        ~ \"*\",\n      p_value &lt; 0.1  ~ \"·\",\n      TRUE                  ~ \"ns\"\n    )) # A R la significació es veu més neta\n\nshapiro_by_group\n\n# A tibble: 64 × 7\n   generation group gene      df     W p_value signif\n   &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt;  &lt;int&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; \n 1 M          REF   gene_1     6 0.853  0.165  ns    \n 2 M          REF   gene_2     6 0.924  0.534  ns    \n 3 M          REF   gene_3     5 0.915  0.498  ns    \n 4 M          REF   gene_4     5 0.970  0.876  ns    \n 5 M          P     gene_1     5 0.738  0.0228 *     \n 6 M          P     gene_2     5 0.735  0.0215 *     \n 7 M          P     gene_3     6 0.978  0.941  ns    \n 8 M          P     gene_4     6 0.856  0.175  ns    \n 9 M          G     gene_1     5 0.858  0.222  ns    \n10 M          G     gene_2     5 0.970  0.876  ns    \n# ℹ 54 more rows\n\n\n\nEn aquest cas el gen_1 i gen_2 en alguns grups i algunes generacions no segueixen la normalitat, llavors en el nostre cas decidiriem que aplicariem tests de no normal en tots els casos, però es podria discutir a veure quin aplicar.\n\nSi ho esteu comprovant amb els valors de SPSS, sobretot que sigui amb la opció de “exclude cases pairwise”. Amb la opció per defecte no ho fa correctament."
  },
  {
    "objectID": "estadistica.html#homogeneïtat-de-les-variàncies",
    "href": "estadistica.html#homogeneïtat-de-les-variàncies",
    "title": "Estadística",
    "section": "Homogeneïtat de les variàncies",
    "text": "Homogeneïtat de les variàncies\nTest Levene per a que ens digui si les variàncies són homogènies (p&gt;0.05) o no són homogènies (p&lt;0.05). Es fa per tots els grups en general, no cal separar grups. En el cas de SPSS es feia amb l’Anova, a R el codi seria:\n\nlibrary(car)\nlevene_long &lt;- longdata %&gt;%\n  group_by(generation, gene) %&gt;%\n  group_modify(~ {\n    \n    # eliminem NA\n    d &lt;- .x[!is.na(.x$value) & !is.na(.x$group), ]\n    \n    # --- Levene clàssics ---\n    lev_mean   &lt;- leveneTest(value ~ group, d, center = mean)\n    lev_median &lt;- leveneTest(value ~ group, d, center = median)\n\n    tibble(\n      method = c(\"Based on Mean\",\"Based on Median\"),\n      F = c(lev_mean[1, \"F value\"],lev_median[1, \"F value\"]),\n      df1 = c(lev_mean[1, \"Df\"],lev_median[1, \"Df\"]     ),\n      df2 = c(lev_mean[2, \"Df\"],lev_median[2, \"Df\"]),\n      p.value = c(lev_mean[1, \"Pr(&gt;F)\"],lev_median[1, \"Pr(&gt;F)\"]))\n  }) %&gt;%\n  ungroup() %&gt;%\n  mutate(                  #per afegir columna de * significació, es pot treure\n    signif = case_when(\n      is.na(p.value)        ~ \"ns\",\n      p.value &lt; 0.001       ~ \"***\",\n      p.value &lt; 0.01        ~ \"**\",\n      p.value &lt; 0.05        ~ \"*\",\n      p.value &lt; 0.1  ~ \"·\",\n      TRUE                  ~ \"ns\"\n    )) # A R la significació es veu més neta\n\nlevene_long\n\n# A tibble: 32 × 8\n   generation gene   method               F   df1   df2 p.value signif\n   &lt;fct&gt;      &lt;fct&gt;  &lt;chr&gt;            &lt;dbl&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt; \n 1 M          gene_1 Based on Mean   2.54       4    22  0.0686 ·     \n 2 M          gene_1 Based on Median 1.52       4    22  0.232  ns    \n 3 M          gene_2 Based on Mean   0.0455     4    22  0.996  ns    \n 4 M          gene_2 Based on Median 0.0161     4    22  0.999  ns    \n 5 M          gene_3 Based on Mean   0.638      4    23  0.641  ns    \n 6 M          gene_3 Based on Median 0.576      4    23  0.683  ns    \n 7 M          gene_4 Based on Mean   0.395      4    22  0.810  ns    \n 8 M          gene_4 Based on Median 0.330      4    22  0.855  ns    \n 9 Cd1        gene_1 Based on Mean   0.235      3    33  0.871  ns    \n10 Cd1        gene_1 Based on Median 0.207      3    33  0.891  ns    \n# ℹ 22 more rows\n\n\n\nEn aquest cas el gen_1 i gen_2 en alguns grups i algunes generacions les variàncies no son homogenies, llavors en el nostre cas decidiriem que aplicariem tests de no homogènies en tots els casos, però es podria discutir a veure quin aplicar.\n\nAquí també tenim una diferència respecte a SPSS, ja que levene no permet NA, llavors en el format wide elimina tota la observació. Al treballar en long només eliminem la observació del gen concret per tant mantenim més dades per als altres gens. Si es vol comprovar o fer, previ al test LEVENE fer:\n\nlongdata2 &lt;- data %&gt;% \n  na.omit() %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\")))\n\nA part SPSS ho feia centrat en la mitjana, mediana (amb R ho fem) i “trimmed mean” i “median and with adjusted df”. Aquestes últimes no les calculem, però no ho crec necessari ja que normalment els resultats son o tots no significatius o tots significatius."
  },
  {
    "objectID": "estadistica.html#independent-samples-t-test",
    "href": "estadistica.html#independent-samples-t-test",
    "title": "Estadística",
    "section": "Independent samples T-test",
    "text": "Independent samples T-test\nPer a comparacions de mitjanes on hi ha dos grups i les mostres son normals: T-test de mostres independents\n\nresults_ttest &lt;- longdata %&gt;%\n  filter(generation == \"CA\") %&gt;% #només aquesta té dos grups\n  group_by(generation, gene) %&gt;%\n  summarise(\n    # fer t-test i guardar el resultat\n    t_res = list(t.test(value ~ group, var.equal = T, alternative = \"two.sided\", conf.level=0.95)), #canviar a F si equal variances not assumed ; paired = F, es separen les variables amb ,\n    .groups = \"drop\"\n  ) %&gt;%\n  rowwise() %&gt;%\n  mutate(\n    t = t_res$statistic,\n    df = t_res$parameter,\n    mean_diff = diff(t_res$estimate),  # Mean difference (group1 - group2)\n    std_error = abs(mean_diff) / abs(t),  # Std. Error Difference\n    p_one_sided = t_res$p.value / 2,\n    p_two_sided = t_res$p.value,\n    sig = case_when(\n      is.na(t_res$p.value)        ~ \"ns\",\n      t_res$p.value &lt; 0.001       ~ \"***\",\n      t_res$p.value &lt; 0.01        ~ \"**\",\n      t_res$p.value &lt; 0.05        ~ \"*\",\n      t_res$p.value &lt; 0.1  ~ \"·\",\n      TRUE                  ~ \"ns\"), #no cal, per visualitzar-ho millor\n    conf_low = t_res$conf.int[1],\n    conf_high = t_res$conf.int[2]\n  ) %&gt;%\n  select(generation, gene, t, df, p_one_sided, p_two_sided, sig, mean_diff, std_error, conf_low, conf_high)\n\nresults_ttest\n\n# A tibble: 4 × 11\n# Rowwise: \n  generation gene        t    df   p_one_sided  p_two_sided sig   mean_diff\n  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;\n1 CA         gene_1 -10.7     16 0.00000000566 0.0000000113 ***        53.6\n2 CA         gene_2  -9.83    15 0.0000000312  0.0000000624 ***        58.3\n3 CA         gene_3  -9.17    17 0.0000000270  0.0000000540 ***        57.4\n4 CA         gene_4 -10.8     15 0.00000000906 0.0000000181 ***        59.9\n# ℹ 3 more variables: std_error &lt;dbl&gt;, conf_low &lt;dbl&gt;, conf_high &lt;dbl&gt;\n\n\n\nEn el cas que la homogeneïtat de variàncies no es compleixi, modificar var.equal = F.\nEn el cas de dades aparellades afegir paired = T i eliminar var.equal\nEn el cas que tenir vectors canvia la formula t.test(value, group). No acostuma a ser el nostre cas, vigilar!!"
  },
  {
    "objectID": "estadistica.html#one-way-anova",
    "href": "estadistica.html#one-way-anova",
    "title": "Estadística",
    "section": "One-way ANOVA",
    "text": "One-way ANOVA\nQuan tenim més de dos grups i les dades són normals i homogènies fem el One-way ANOVA, amb el post-hoc ajustat per Bonferroni.\nAquest codi només mostra el resultat\n\nlongdata %&gt;% \n  filter(generation %in% c(\"M\", \"Cd1\", \"Cd21\")) %&gt;%\n  mutate(gene_name = gene) %&gt;%\n  group_by(gene) %&gt;%\n  group_walk(~ {\n    cat(\"\\n====================\\n\")\n    cat(\"GENE:\", unique(.x$gene_name), \"\\n\")\n    cat(\"Generation:\", unique(.x$generation), \"\\n\")\n    print(summary(aov(value ~ group, data = .x)))\n  })\n\n\n====================\nGENE: 1 \nGeneration: 1 2 3 \n             Df Sum Sq Mean Sq F value Pr(&gt;F)    \ngroup         4  67709   16927   120.8 &lt;2e-16 ***\nResiduals   104  14572     140                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n11 observations deleted due to missingness\n\n====================\nGENE: 2 \nGeneration: 1 2 3 \n             Df Sum Sq Mean Sq F value Pr(&gt;F)    \ngroup         4  74249   18562   93.29 &lt;2e-16 ***\nResiduals   105  20892     199                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n10 observations deleted due to missingness\n\n====================\nGENE: 3 \nGeneration: 1 2 3 \n             Df Sum Sq Mean Sq F value Pr(&gt;F)    \ngroup         4  75457   18864   106.1 &lt;2e-16 ***\nResiduals   106  18840     178                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n9 observations deleted due to missingness\n\n====================\nGENE: 4 \nGeneration: 1 2 3 \n             Df Sum Sq Mean Sq F value Pr(&gt;F)    \ngroup         4  69539   17385   95.81 &lt;2e-16 ***\nResiduals   105  19052     181                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n10 observations deleted due to missingness\n\n\nAquest altre crea una taula per copiar a l’excel\n\nlibrary(rstatix)\n\nresults_anova &lt;- longdata %&gt;%\n  filter(generation %in% c(\"M\", \"Cd1\", \"Cd21\")) %&gt;% #seleccionar aquelles que sigui                                                         el test correcte\n  group_by(generation, gene) %&gt;%\n  group_map(~ {\n    model &lt;- aov(value ~ group, data = .x)\n    # taula tidy del model\n    tidy_model &lt;- tidy(model)%&gt;% \n      mutate(gene = .y$gene) %&gt;% \n      mutate(generation = .y$generation)\n    # fila TOTAL\n    total_row &lt;- tibble(\n      term = \"Total\",\n      df = sum(tidy_model$df, na.rm = TRUE),\n      sumsq = sum(tidy_model$sumsq, na.rm = TRUE),\n      meansq = NA_real_,\n      statistic = NA_real_,\n      p.value = NA_real_,\n      gene = .y$gene\n    )\n    bind_rows(tidy_model, total_row) \n  }) %&gt;%\n  bind_rows() %&gt;%\n  select(generation, gene, everything())   %&gt;%\n  mutate(\n    signif = case_when(\n      is.na(p.value)  ~ \"ns\",\n      p.value &lt; 0.001 ~ \"***\",\n      p.value &lt; 0.01  ~ \"**\",\n      p.value &lt; 0.05  ~ \"*\",\n      p.value &lt; 0.1  ~ \"·\",\n      TRUE            ~ \"ns\"))\n\nresults_anova\n\n# A tibble: 36 × 9\n   generation gene   term         df  sumsq meansq statistic  p.value signif\n   &lt;fct&gt;      &lt;fct&gt;  &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt; \n 1 M          gene_1 group         4 17584.  4396.      30.8  1.01e-8 ***   \n 2 M          gene_1 Residuals    22  3144.   143.      NA   NA       ns    \n 3 &lt;NA&gt;       gene_1 Total        26 20728.    NA       NA   NA       ns    \n 4 M          gene_2 group         4 24297.  6074.      34.8  3.23e-9 ***   \n 5 M          gene_2 Residuals    22  3843.   175.      NA   NA       ns    \n 6 &lt;NA&gt;       gene_2 Total        26 28140.    NA       NA   NA       ns    \n 7 M          gene_3 group         4 21158.  5290.      28.5  1.29e-8 ***   \n 8 M          gene_3 Residuals    23  4266.   185.      NA   NA       ns    \n 9 &lt;NA&gt;       gene_3 Total        27 25425.    NA       NA   NA       ns    \n10 M          gene_4 group         4 16595.  4149.      20.0  4.52e-7 ***   \n# ℹ 26 more rows\n\n\nSi fem cada gen per separat el codi és molt més senzill, però tenim més feina manual\n\ndades_anova &lt;- longdata %&gt;% \n  filter(generation == \"M\", gene == \"gene_1\")\nanova &lt;- aov(value ~ group,dades_anova)\nclass(anova)\n\n[1] \"aov\" \"lm\" \n\nsummary(anova)\n\n            Df Sum Sq Mean Sq F value   Pr(&gt;F)    \ngroup        4  17584    4396   30.76 1.01e-08 ***\nResiduals   22   3144     143                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n3 observations deleted due to missingness\n\n\n\nPost-hoc ajustat per Bonferroni\nEn el cas que doni diferències significatives, passem a fer el post-hoc.\n\nAl fer emmeans: Aquest codi agafa cada model ANOVA, calcula les mitjanes ajustades, fa totes les comparacions parell a parell amb Bonferroni, i retorna estimacions + intervals de confiança + p-valors.\n\n\nlibrary(emmeans)\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\nposthoc_results &lt;- longdata %&gt;% \n  filter(generation %in% c(\"M\", \"Cd1\", \"Cd21\")) %&gt;%\n  group_by(generation, gene) %&gt;%\n  nest() %&gt;%\n  mutate(\n    aov_model = map(data, ~ aov(value ~ group, data = .x)),\n    posthoc = map(\n      aov_model,\n      ~ emmeans(.x, ~ group) %&gt;%\n        contrast(\"pairwise\", adjust = \"bonferroni\") %&gt;%\n        summary(level = 0.95,infer = c(TRUE, TRUE)) %&gt;%   # IC + p-value\n        as.data.frame())) %&gt;%\n  select(generation, gene, posthoc) %&gt;%\n  unnest(posthoc) %&gt;%\n  mutate(\n    signif = case_when(\n      is.na(p.value)  ~ \"ns\",\n      p.value &lt; 0.001 ~ \"***\",\n      p.value &lt; 0.01  ~ \"**\",\n      p.value &lt; 0.05  ~ \"*\",\n      p.value &lt; 0.1  ~ \"·\",\n      TRUE            ~ \"ns\"))   \n\nposthoc_results\n\n# A tibble: 104 × 11\n# Groups:   generation, gene [12]\n   generation gene   contrast  estimate    SE    df lower.CL upper.CL t.ratio\n   &lt;fct&gt;      &lt;fct&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1 M          gene_1 REF - P     -26.3   7.24    22   -48.8    -3.69    -3.63\n 2 M          gene_1 REF - G      24.4   7.24    22     1.81   47.0      3.37\n 3 M          gene_1 REF - S       9.55  6.90    22   -12.0    31.1      1.38\n 4 M          gene_1 REF - PGS   -49.1   7.24    22   -71.7   -26.5     -6.78\n 5 M          gene_1 P - G        50.7   7.56    22    27.1    74.2      6.70\n 6 M          gene_1 P - S        35.8   7.24    22    13.2    58.4      4.95\n 7 M          gene_1 P - PGS     -22.8   7.56    22   -46.4     0.741   -3.02\n 8 M          gene_1 G - S       -14.8   7.24    22   -37.4     7.74    -2.05\n 9 M          gene_1 G - PGS     -73.5   7.56    22   -97.1   -49.9     -9.72\n10 M          gene_1 S - PGS     -58.7   7.24    22   -81.2   -36.1     -8.10\n# ℹ 94 more rows\n# ℹ 2 more variables: p.value &lt;dbl&gt;, signif &lt;chr&gt;\n\n\nSi ho fèssim per cada gen alhora ho podriem fer amb aquestes fòrmules:\n\npairwise.t.test( x = dades_anova$value,   # outcome variable\n                 g = dades_anova$group_name,        # grouping variable\n                 p.adjust.method = \"none\"    # which correction to use?\n)\n\n#o\nlibrary(lsr)\nposthocPairwiseT( x = results_anova, p.adjust.method = \"bonferroni\" )\n\n\n\nPost-hoc Games-Howell\nEn el cas de dades normals però no homogènies, amb l’SPSS faríem Dunnet T3. En R no existeix així que es fa el Games-Howell.\n\nlibrary(rstatix)\nposthoc_gameshowell &lt;- longdata %&gt;%\n  filter(generation == \"M\") %&gt;%\n  group_by(gene) %&gt;%\n  games_howell_test(value ~ group)\n\nposthoc_gameshowell\n\n# A tibble: 40 × 9\n   gene   .y.   group1 group2 estimate conf.low conf.high     p.adj p.adj.signif\n * &lt;fct&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       \n 1 gene_1 value REF    P         26.3      8.52     44.0  0.007     **          \n 2 gene_1 value REF    G        -24.4    -54.3       5.55 0.105     ns          \n 3 gene_1 value REF    S         -9.55   -36.1      17.0  0.697     ns          \n 4 gene_1 value REF    PGS       49.1     34.9      63.4  0.0000101 ****        \n 5 gene_1 value P      G        -50.7    -80.7     -20.6  0.004     **          \n 6 gene_1 value P      S        -35.8    -63.1      -8.50 0.012     *           \n 7 gene_1 value P      PGS       22.8      4.58     41.1  0.017     *           \n 8 gene_1 value G      S         14.8    -18.2      47.9  0.578     ns          \n 9 gene_1 value G      PGS       73.5     43.6     103.   0.000744  ***         \n10 gene_1 value S      PGS       58.7     32.0      85.3  0.00066   ***         \n# ℹ 30 more rows"
  },
  {
    "objectID": "estadistica.html#u-mann-whitney",
    "href": "estadistica.html#u-mann-whitney",
    "title": "Estadística",
    "section": "U-Mann Whitney",
    "text": "U-Mann Whitney\nQuan tenim dos grups i les dades no són ni normals ni homogènies fem el test de U-Mann Whitney.\n\nresults_umw &lt;- longdata %&gt;%\n  filter(generation == \"CA\") %&gt;%\n  group_by(gene) %&gt;%\n  wilcox_test(value ~ group) #el que dona R per defecte\n\nresults_umw\n\n# A tibble: 4 × 8\n  gene   .y.   group1 group2    n1    n2 statistic         p\n* &lt;fct&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 gene_1 value REF    PGS        9     9         0 0.000409 \n2 gene_2 value REF    PGS        9     8         0 0.0000823\n3 gene_3 value REF    PGS        9    10         0 0.0000217\n4 gene_4 value REF    PGS        9     8         0 0.000631"
  },
  {
    "objectID": "estadistica.html#kruskall-wallis",
    "href": "estadistica.html#kruskall-wallis",
    "title": "Estadística",
    "section": "Kruskall-Wallis",
    "text": "Kruskall-Wallis\nQuan tenim més de dos grups i les dades no són ni normals ni homogènies fem el test de Kruskall-Wallis.\nNomés l’imprimeix\n\nlongdata %&gt;% \n  filter(generation == \"M\") %&gt;%\n  mutate(gene_name = gene) %&gt;% \n  group_by(gene) %&gt;%\n  group_walk(~ {\n    cat(\"\\n====================\\n\")\n    cat(\"GENE:\", unique(.x$gene_name), \"\\n\")\n    print(kruskal.test(value ~ group, data = .x))\n  })\n\n\n====================\nGENE: 1 \n\n    Kruskal-Wallis rank sum test\n\ndata:  value by group\nKruskal-Wallis chi-squared = 22.311, df = 4, p-value = 0.0001738\n\n\n====================\nGENE: 2 \n\n    Kruskal-Wallis rank sum test\n\ndata:  value by group\nKruskal-Wallis chi-squared = 19.741, df = 4, p-value = 0.0005618\n\n\n====================\nGENE: 3 \n\n    Kruskal-Wallis rank sum test\n\ndata:  value by group\nKruskal-Wallis chi-squared = 21.543, df = 4, p-value = 0.0002471\n\n\n====================\nGENE: 4 \n\n    Kruskal-Wallis rank sum test\n\ndata:  value by group\nKruskal-Wallis chi-squared = 18.413, df = 4, p-value = 0.001025\n\n\nPer a copiar-lo a l’excel.\n\nresults_kruskal &lt;- longdata %&gt;%\n  filter(generation %in% c(\"M\", \"Cd1\", \"Cd21\")) %&gt;%\n  group_by(generation, gene) %&gt;%\n  group_map(~ {\n    # Kruskal–Wallis test\n    model &lt;- kruskal.test(value ~ group, data = .x)\n    # tidy del test\n    tidy_model &lt;- tidy(model) %&gt;%\n      mutate(\n        generation = .y$generation,\n        gene = .y$gene,\n        df = parameter \n      ) %&gt;%\n      select(generation, gene,df,statistic,p.value)\n  }) %&gt;%\n  bind_rows() %&gt;% \n  mutate(\n    signif = case_when(\n      is.na(p.value)  ~ \"ns\",\n      p.value &lt; 0.001 ~ \"***\",\n      p.value &lt; 0.01  ~ \"**\",\n      p.value &lt; 0.05  ~ \"*\",\n      p.value &lt; 0.1  ~ \"·\",\n      TRUE            ~ \"ns\"))\n\nresults_kruskal\n\n# A tibble: 12 × 6\n   generation gene      df statistic     p.value signif\n   &lt;fct&gt;      &lt;fct&gt;  &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt; \n 1 M          gene_1     4      22.3 0.000174    ***   \n 2 M          gene_2     4      19.7 0.000562    ***   \n 3 M          gene_3     4      21.5 0.000247    ***   \n 4 M          gene_4     4      18.4 0.00102     **    \n 5 Cd1        gene_1     3      29.9 0.00000145  ***   \n 6 Cd1        gene_2     3      26.0 0.00000967  ***   \n 7 Cd1        gene_3     3      30.0 0.00000136  ***   \n 8 Cd1        gene_4     3      28.8 0.00000242  ***   \n 9 Cd21       gene_1     4      31.2 0.00000284  ***   \n10 Cd21       gene_2     4      32.6 0.00000143  ***   \n11 Cd21       gene_3     4      27.1 0.0000186   ***   \n12 Cd21       gene_4     4      35.2 0.000000430 ***   \n\n\nSi son significatius, fem el post-hoc Dunn.\n\nPost-hoc Dunn amb correcció de Bonferroni\nQuan les dades no siguin ni normals ni homogènies, es fa el test post-hoc de Dunn amb la correcció de Bonferroni.\n\nposthoc_dunn &lt;- longdata %&gt;%\n  filter(generation == \"M\") %&gt;%\n  group_by(gene) %&gt;%\n  dunn_test(\n    value ~ group,\n    p.adjust.method = \"bonferroni\")\n\nposthoc_dunn\n\n# A tibble: 40 × 10\n   gene   .y.   group1 group2    n1    n2 statistic       p   p.adj p.adj.signif\n * &lt;fct&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;       \n 1 gene_1 value REF    P          6     5     1.46  1.45e-1 1   e+0 ns          \n 2 gene_1 value REF    G          6     5    -1.75  8.03e-2 8.03e-1 ns          \n 3 gene_1 value REF    S          6     6    -0.946 3.44e-1 1   e+0 ns          \n 4 gene_1 value REF    PGS        6     5     2.50  1.25e-2 1.25e-1 ns          \n 5 gene_1 value P      G          5     5    -3.07  2.14e-3 2.14e-2 *           \n 6 gene_1 value P      S          5     6    -2.36  1.83e-2 1.83e-1 ns          \n 7 gene_1 value P      PGS        5     5     0.997 3.19e-1 1   e+0 ns          \n 8 gene_1 value G      S          5     6     0.847 3.97e-1 1   e+0 ns          \n 9 gene_1 value G      PGS        5     5     4.07  4.76e-5 4.76e-4 ***         \n10 gene_1 value S      PGS        6     5     3.40  6.72e-4 6.72e-3 **          \n# ℹ 30 more rows"
  },
  {
    "objectID": "estadistica.html#art-anova",
    "href": "estadistica.html#art-anova",
    "title": "Estadística",
    "section": "Art ANOVA",
    "text": "Art ANOVA\nQuan tenim més de dos grups, les dades no són ni normals ni homogènies i hi ha dues variables independents, és fa Art ANOVA. És molt poc comú necessitar aquest test.\nAquest test l’ha fet amb R la Sofía, com que no s’acostuma a necessitar no l’he generalitzat, però us adjunto l’script per si us interessa.\n2 factors\n3 factors"
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Basics",
    "section": "",
    "text": "Per començar ens haurem de descarregar:\n\nR (https://ftp.cixug.es/CRAN/index.html)\nRstudio (https://posit.co/download/rstudio-desktop/)\n\nUn cop ho tingueu instal·lat ja podem començar."
  },
  {
    "objectID": "basics.html#installació",
    "href": "basics.html#installació",
    "title": "Basics",
    "section": "",
    "text": "Per començar ens haurem de descarregar:\n\nR (https://ftp.cixug.es/CRAN/index.html)\nRstudio (https://posit.co/download/rstudio-desktop/)\n\nUn cop ho tingueu instal·lat ja podem començar."
  },
  {
    "objectID": "basics.html#zona-de-treball",
    "href": "basics.html#zona-de-treball",
    "title": "Basics",
    "section": "Zona de treball",
    "text": "Zona de treball\nTenim dues maneres de treballar, creant un projecte o agafant una carpeta qualsevol i treballant en un directori de treball.\nLa més senzilla és creant un directori de treball (working directory). Allà hem de tenir el nostre document .csv o .xlsx amb les dades. També serà la carpeta on ens guardarà imatges o documents en cas que ho demanem mitjançant codi.\nEs pot indicar de la següent manera:\n\nTambé es pot indicar mitjançant codi (jo ho prefereixo):\n\nsetwd(\"C:/pathway que ha de seguir per arribar a la carpeta d'interés\")\n\nPer altre banda es pot crear un projecte (millor si ho vols tenir tot més organitzat):\n\nEn aquest cas pots crear diferents carpetes a dins del projecte directament desde la finestra de “Files” a l’extrem dret inferior. Recomano crear-ne tres mínim anomenats:\n\n“data”: col·locar el fitxer amb les dades\n“scripts”: on guardaràs els scripts\n“output”: on gruardar els gràfics\n\nEn el cas que feu análisis en més d’un dataset, recomano crear carpetes per a cada un, per exemple “PCR” i dins d’aquesta les tres que acabo de dir."
  },
  {
    "objectID": "basics.html#script",
    "href": "basics.html#script",
    "title": "Basics",
    "section": "Script",
    "text": "Script\nL’script son les instruccions que aniràs escrivint. Alguns trucs que he anat descobrint són…\nSi escrius una “ordre”, apareix en negre i s’executarà al tenir en cursor a la línia (o seleccionar-ne una o varies) i posar Run. Una altre manera que a mi m’agrada més és amb el teclat: Ctrl + Enter\n\nView(data) \n\nPer posar un comentari poses un # i tot el que estigui darrere no s’executarà\n\n#en aquest cas no s'executarà res\n\nView(data) #en aquest altre cas executarà la ordre i tindràs el comentari\n\n#View(data) aquest cas és incorrecte si vols executar l'ordre ja que no ho farà\n\nUna altre característica xula és que a dins l’script pots anar creant un índex, que apareix a l’outline. Per activar-ho simplement has de colocar mínim 4 ---- al final del comentari. Al posar diferent número de # crearas diferent subnivells.\nAixò també fa que aparegui una pestanyeta a l’esquerra del títol i permetrà amagar tota aquella secció, fent la revisió i lectura de l’script sencer més còmode.\n\n#Títol 1 ----\n## Subtítol----\n### Sub-subtítol ----\n#### encara més subtitol ----\n#Títol 2 ----"
  },
  {
    "objectID": "basics.html#installar-i-carregar-paquets",
    "href": "basics.html#installar-i-carregar-paquets",
    "title": "Basics",
    "section": "Instal·lar i carregar paquets",
    "text": "Instal·lar i carregar paquets\nR té funcions bàsiques, però per fer-te la vida més fàcil molta gent ha creat funcions que et pots descarregar en paquets. El primer cop que l’utilitzis has d’instal·lar-lo i carregar-lo i els següents només carregar-lo.\n\ninstall.packages(\"nom paquet\")\nlibrary(nom paquet)\n\nEls que jo sempre utilitzo són:\n\nlibrary(tidyverse) #conté 9 paquets d'edició i visualització \nlibrary(here) #al treballar en un projecte\nlibrary(readxl) #per importar dades que estan en un fitxer d'excel\nlibrary(janitor) #ajudar a netejar les dades\nlibrary(skimr) #per obtenir un resum de les dades complert\nlibrary(broom) #poder fer servir funcions com tidy\nlibrary(rstatix) #funcions d'estadística"
  },
  {
    "objectID": "basics.html#importar-dades",
    "href": "basics.html#importar-dades",
    "title": "Basics",
    "section": "Importar dades",
    "text": "Importar dades\nAmb la zona de treball preparada i els paquets instal·lats i carregats ja podem començar a treballar, i el primer serà importar les dades.\nDesde un working directory:\n\nraw_data&lt;- read_excel(\"nom excel.xlsx\", sheet = \"nom full\")\n\nEn un projecte amb el paquet library(here):\n\nraw_data &lt;- read_excel(here(\"data\", \"nom excel.xlsx\"),  sheet = \"nom full\")\n\n#en el cas de estar en una subcarpeta\nraw_data &lt;- read_excel(here(\"nom subcarpeta\", \"data\", \"nom excel.xlsx\"),  sheet = \"nom full\")\n\nSeguidament comprovem que s’han importat bé.\n\nView(raw_data) #Mirar tota la taula\nhead(raw_data) #imprimeix només el principi de les dades\nskim(raw_data) #obtenir estadístics descriptius i característiques de les variables\n\nSi tot està correcte ja podem començar amb el que vulguem."
  },
  {
    "objectID": "basics.html#descarregar-dades-i-figures",
    "href": "basics.html#descarregar-dades-i-figures",
    "title": "Basics",
    "section": "Descarregar dades i figures",
    "text": "Descarregar dades i figures\nAbans de passar a l’anàlisi de dades us indico com descarregar-vos arxius que hagueu generat:\n\nDataframes\n\n\nlibrary(writexl)\nwrite_xlsx(nom_dataframe, \"nom fitxer.xlsx\")  #amb working directory\nwrite_xlsx(nom_dataframe, here(\"pre-carpeta\",\"data\", \"nom fitxer.xlsx\"))   #amb projecte\n\n\nFigures amb ggplot (paquet inclós dins de tidyverse )\n\n\nggsave(here(\"output\",\"nom fitxer.png\"), width = 12, height = 3, dpi = 300) \n#pots canviar la mida i la resolució (dpi)"
  },
  {
    "objectID": "basics.html#altres-bàsics",
    "href": "basics.html#altres-bàsics",
    "title": "Basics",
    "section": "Altres bàsics",
    "text": "Altres bàsics\nFinalment, escriuré funcions molt bàsiques que segurament ja conegueu però per tenir-les recollides.\nR és una calculadora amb memòria per tant es poden fer operacions bàsiques, suma, resta…\nGenerar objectes obj &lt;- x (Shortcut per a posar &lt;-: alt + -)\nDefinir vectors vec &lt;- c(x, y, z)\nDefinir matrius mat &lt;- matrix(data=c(x, y, z), nrow=X, ncol=Y)\nAccedir a elements del dataframe:\n\nColumna pel nom data$nomcolumna\nElement per coordenades data[fila, columna]\nRang dades data[x:y,] #(buit=tot)\n\nFuncions interessants primera vista a les dades (i comprovar que tot bé)\ndim(data) , str(data) , glimpse(data) , head(data) / tail(data) , View(data) , glimpse(data)\nNetejar dades Netejar dades: canviar tots els caràcters dels noms de les columnes\ndata &lt;- select_all(data, tolower/toupper)\ndata &lt;- rename(data, newname=oldname)\nReordenar columnes o triar quines vols en un nou dataframe\nselect(data, col1, col2, col3, everything())\nEn el cas de resultats obtinguts, per exemple result.test, la majoria són elements tipus llista.\n\nAccedir element concret: Nomllista$nomobjecte (result.test$p.value)\nVeure tots elements str(nomllista)\n\nSepara o ajuntar columnes (i mantenir inicial): separate /unite (remove=F)\nCanviar o afegir columnes amb operacions mutate\n… entre moltes d’altres que ja aniré explicant."
  },
  {
    "objectID": "basics.html#programació-en-r",
    "href": "basics.html#programació-en-r",
    "title": "Basics",
    "section": "Programació en R",
    "text": "Programació en R\nRealment R és un llenguatge de programació, per tant es poden fer altres coses molt interessants com loops. Aquí ja no entraré però si estàs interessat que sàpiques que existeixen i a vegades el ChatGPT en crea, per tant que els sàpigues interpretar si t’apareixen.\n\n#Loops\nwhile ( CONDITION ) {\n  STATEMENT1\n  STATEMENT2\n  ETC\n} #mentre la condició es compleixi anirà fent el que tingui a dins i repetirà fins que es deixi de complir\n\nfor ( VAR in VECTOR ) {\n  STATEMENT1\n  STATEMENT2\n  ETC\n} #nombre finit, per cada variable al vector farà el que li demanis fins que acabi amb totes. \n\nif ( CONDITION ) { #si aquesta condició es compleix farà els statement 1 i 2\n  STATEMENT1\n  STATEMENT2\n  ETC\n} else { #si no es compleix l'altre fer aquesta\n  STATEMENT3\n  STATEMENT4\n  ETC\n} \n\nFNAME &lt;- function ( ARG1, ARG2, ETC ) { #funcions\n  STATEMENT1\n  STATEMENT2\n  ETC\n  return( VALUE )\n}\n\nAnàlisi de dades\nPerfecte, doncs ara que ja sabem què és un script i com carregar dades començarem a tractar-les.\nEl meu tip és que tot i que per a fer un anàlisi no necessitis certes variables, tu les col·loquis totes al teu full de càlcul. En el meu cas jo estic treballant amb rates que reben una dieta materna i treballo tant amb les mares com amb la descendència. Per tant faré les següents columnes sempre:\n\nrat: identificador de la rata\ngeneration: a quina generació pertanyen (“M”, “Cd1”, “Cd21”, “CA”)\nsex: el sexe de la rata (“M”, “F”, “ns”)\ngroup: a quin grup de dieta pertanyen (“REF”, “P”, “G”, “S”, “PGS”)\nvariables d’interés: columnes diferents amb títol de cada variable i els valors que ha obtingut cada rata.\n\nPCR: una columna per cada gen\nLipidòmica: una columna per cada lípid\nBeads: una columna per cada Ig\ni un llarg etcètera\n\n\nSi un dia jo només tinc rates que son de la generació “M”, igualment fer una columna i indicar-ho, ja que un cop a dins de R, podem treure columnes si no ens interessen, o ajuntar dos datasets diferents on llavors potser sí que és interessant tenir aquesta informació.\nEl que si que no recomano és tenir dues columnes amb la mateixa informació, com per exemple una columna on el grup estigui codificat amb lletres i una altre amb números. Si en algun moment ho necessitem, simplement mutarem la columna existent i ja està.\nUna altre recomanació és fer els noms de columnes, i les variables a dins seu, el més simple possible. Això és degut a que després, quan creem el codi, segurament ho haurem d’escriure EXACTAMENT igual, per tant com més simple menys maldecaps. Si esteu fent servir algun dataset que no teniu preparat per això no us preocupeu, hi ha maneres de fer-lo més simple dins d’R.\n\ngrup enlloc de Grup\nM enlloc de Mascles\n\nA més a més el meu dataset és complicat ja que no tinc el mateix nombre de grups per cada generació. Aquí teniu una taula resum que serà útil per entendre els anàlisis estadístics posteriors.\n\n\n\nGeneració\nGrups\nSexe\nRates per grup\n\n\n\n\nM\nREF, P, G, S, PGS\nF\n6\n\n\nCd1\nREF, P, G, PGS\nM, F\n10\n\n\nCd21\nREF, P, G, S, PGS\nM, F\n10\n\n\nCA\nREF, PGS\nM, F\n10\n\n\n\nPer a que no hi hagi problemes de filtració de dades li he demanat a ChatGPT que em crei un dataset d’aquestes característiques, així que totes les dades que faré servir i els resultats són inventats.\nAixò si, jo ja he fet un pre-processat de les dades amb l’excel en el que he tret els outliers de cada grup (per tant alguna cel·la estarà buida i tindré NA) i els valors que introdueixo són expressió relativa respecte el grup REF de la seva generació, en %. Si no ho teniu fet es podria fer tot dins de l’R però jo per començar no m’he complicat tant.\nL’excel llueix així:\n\nImportem les dades i comprovem que estan bé i els grups que existeixen corresponen al que hem indicat:\n\nlibrary(readxl)\nlibrary(here)\nraw_data &lt;- read_excel(here(\"Basic\", \"data\", \"PCR.xlsx\"),  sheet = \"relative\")\nView(raw_data)\nlibrary(skimr)\nskim(raw_data)\n\n\nData summary\n\n\nName\nraw_data\n\n\nNumber of rows\n140\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n4\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngeneration\n0\n1\n1\n4\n0\n4\n0\n\n\ngroup\n0\n1\n1\n3\n0\n5\n0\n\n\nsex\n0\n1\n1\n1\n0\n2\n0\n\n\nrat\n0\n1\n2\n5\n0\n122\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ngene_1\n13\n0.91\n115.60\n28.32\n61.3\n93.70\n106.7\n139.25\n170.7\n▂▇▃▃▃\n\n\ngene_2\n13\n0.91\n119.72\n30.46\n67.2\n97.00\n111.4\n141.20\n192.4\n▅▇▅▃▂\n\n\ngene_3\n10\n0.93\n119.48\n29.84\n50.7\n97.30\n109.0\n146.48\n182.1\n▁▇▅▅▃\n\n\ngene_4\n13\n0.91\n119.15\n29.24\n67.0\n96.05\n110.2\n143.40\n182.6\n▂▇▃▅▂\n\n\n\n\n\nCom veiem, ens ha fet un resum general de les dades i variables, totes com a conjunt.\nAnem a teure’ls-hi suc."
  },
  {
    "objectID": "basics.html#tidyverse",
    "href": "basics.html#tidyverse",
    "title": "Basics",
    "section": "Tidyverse",
    "text": "Tidyverse\nPer tal de fer-nos la vida més fàcil, altre gent que treballa amb R ha creat el paquet tidyverse el qual, com ja he dit, conté els paquets més importants per a transformar dades i graficar-les. També hi ha gent molt generosa que ha fet CheatSheets dels paquets més útils, que us recomano imprimir i tenir sempre a mà: https://posit.co/resources/cheatsheets/\n\nlibrary(tidyverse) \n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.1     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(janitor)\n\n\nS'està adjuntant el paquet: 'janitor'\n\nEls següents objectes estan emmascarats des de 'package:stats':\n\n    chisq.test, fisher.test\n\nlibrary(broom) \nlibrary(rstatix)\n\n\nS'està adjuntant el paquet: 'rstatix'\n\nL'objecte següent està emmascarat per 'package:janitor':\n\n    make_clean_names\n\nL'objecte següent està emmascarat per 'package:stats':\n\n    filter\n\n\nUna de les característiques més interessants és la pipeline %&gt;% (o ara més nou de R |&gt; ). Aquesta funció del paquet dyplr permet enllaçar moltes accions i que vagin succeint de manera seqüencial en un dataframe.\nPrimer s’indica el dataframe i després comeces a fer accions. Per tant dins d’aquestes accions ja no cal que indiquis quin dataset ha d’agafar.\nPer altra banda pots fer certes accions a partir de condicions que es troben en un altre dataset (ja ho veurem més endavant)."
  },
  {
    "objectID": "basics.html#crear-nous-dataset",
    "href": "basics.html#crear-nous-dataset",
    "title": "Basics",
    "section": "Crear nous dataset",
    "text": "Crear nous dataset\nEl següent pas un cop hem importat el dataset és determinar quin tipus de variable és cada una, i a mi m’agrada crear un nou dataset amb les modificacions i deixar el raw_data intacte per si en algun moment necessitem alguna dada o fem modificacions irreversibles sense voler no haver de tornar a importar.\nSi volem grardar el nou dataset és important posar davant de l’acció data nom_dataset &lt;- d’aquesta manera crearem un dataset amb el nom que triem amb les accions que hem indicat.\n\ndata &lt;- raw_data %&gt;% #farà les accions sobre el dataset anomenat raw_data\n  mutate(across(c(group, sex, rat, generation), as.factor)) #definir totes les variables que son factors\nskim(data)\n\n\nData summary\n\n\nName\ndata\n\n\nNumber of rows\n140\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n4\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\ngeneration\n0\n1\nFALSE\n4\nCd2: 50, Cd1: 40, M: 30, CA: 20\n\n\ngroup\n0\n1\nFALSE\n5\nPGS: 36, REF: 36, G: 26, P: 26\n\n\nsex\n0\n1\nFALSE\n2\nF: 85, M: 55\n\n\nrat\n0\n1\nFALSE\n122\nG1.: 2, G3.: 2, G8.: 2, P2.: 2\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ngene_1\n13\n0.91\n115.60\n28.32\n61.3\n93.70\n106.7\n139.25\n170.7\n▂▇▃▃▃\n\n\ngene_2\n13\n0.91\n119.72\n30.46\n67.2\n97.00\n111.4\n141.20\n192.4\n▅▇▅▃▂\n\n\ngene_3\n10\n0.93\n119.48\n29.84\n50.7\n97.30\n109.0\n146.48\n182.1\n▁▇▅▅▃\n\n\ngene_4\n13\n0.91\n119.15\n29.24\n67.0\n96.05\n110.2\n143.40\n182.6\n▂▇▃▅▂\n\n\n\n\n\nSi tenim noms molt complicats, podem afegir abansclean_names() i posa tots els noms de columna en minuscula i sense espais, per fer més fàcil el codi, necessita paquet janitor\nSi us hi fixeu ara les variables que eren de categoria character per defecte, ara son factor i ja es veuen els nivells.\n\nFiltrar dades\nSi per exemple volem extreure només les dades de la generació “M” podriem crear un altre dataset de la següent manera:\n\ndams &lt;- data %&gt;% \n  filter(generation == \"M\")  \nskim(dams)\n\n\nData summary\n\n\nName\ndams\n\n\nNumber of rows\n30\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n4\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\ngeneration\n0\n1\nFALSE\n1\nM: 30, CA: 0, Cd1: 0, Cd2: 0\n\n\ngroup\n0\n1\nFALSE\n5\nG: 6, P: 6, PGS: 6, REF: 6\n\n\nsex\n0\n1\nFALSE\n1\nF: 30, M: 0\n\n\nrat\n0\n1\nFALSE\n30\nG1: 1, G3: 1, G4: 1, G6: 1\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ngene_1\n3\n0.90\n110.77\n28.24\n61.3\n94.15\n105.0\n130.55\n161.7\n▃▇▂▅▅\n\n\ngene_2\n3\n0.90\n115.63\n32.90\n67.8\n89.60\n105.2\n137.10\n175.5\n▅▇▁▃▃\n\n\ngene_3\n2\n0.93\n118.07\n30.69\n50.7\n94.45\n110.8\n145.80\n173.7\n▁▇▆▅▅\n\n\ngene_4\n3\n0.90\n116.40\n28.53\n71.2\n96.40\n108.8\n134.15\n177.1\n▃▇▅▂▃\n\n\n\n\n\nLa funció filter() és molt interessant ja que podem fer-ho de una variable només un nivell amb == \"nom variable\" o de diferents nivells %in%c(\"nom1\", \"nom2\") i alhora de diferents variables i diferents nivells\n\ndata %&gt;% \n  filter(generation  %in% c(\"M\", \"CA\"), group == \"REF\" )  \n\n# A tibble: 16 × 8\n   generation group sex   rat   gene_1 gene_2 gene_3 gene_4\n   &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 M          REF   F     R1     105     94     95.2  101  \n 2 M          REF   F     R2      98.6  118.    98.1  110. \n 3 M          REF   F     R6     106.    99.9   88.9   NA  \n 4 M          REF   F     R8     115.    89.4   88     96.7\n 5 M          REF   F     R9      97.7  108.   108.    96.1\n 6 M          REF   F     R10     97.7   87.8   NA     85.4\n 7 CA         REF   F     R1.2    93.8  108.    94.4  101. \n 8 CA         REF   F     R1.3    94.4  105.   119.    93.2\n 9 CA         REF   F     R1.6    93.6   NA     85.5  108. \n10 CA         REF   F     R2.6   112.   112.    78     NA  \n11 CA         REF   F     R2.7   114.   114.   104.    95.5\n12 CA         REF   M     R6.6    NA    118.    84.8  114. \n13 CA         REF   M     R6.7   103.   106.    NA     93.2\n14 CA         REF   M     R8.2   125.    96.4  104.   118  \n15 CA         REF   M     R8.3    93.6  106.   116.    99.6\n16 CA         REF   M     R8.6    94.7  111.    99.3   85.7\n\n\nFixeu-vos que en aquest cas m’ho ensenya directament. Això és degut a que no m’ho està guardant com a dataframe perquè no he posat nom_dataset &lt;- davant de les dades. Pot ser útil per comprovar si el teu codi fa el que vols abans de crear el dataframe."
  },
  {
    "objectID": "basics.html#wide-format-vs-long-format",
    "href": "basics.html#wide-format-vs-long-format",
    "title": "Basics",
    "section": "Wide format vs Long format",
    "text": "Wide format vs Long format\nUn concepte molt important a l’hora de utilitzar R és el wide dataset vs long dataset.\n\nEn aquesta imatge tenim a l’esquerra el format wide, que és el que estem més acostumats a crear en excel, i a la dreta el format long, el qual és el que li va millor a R per la majoria de funcions. En el nostre cas li hem donat una taula en format wide ja que tenim una rata a cada fila, i tenim una columna per a cada variable de gen. Per a tenir-ho en format long volem una columna que ens digui de quin gen es tracta aquella observació i una altre columna amb el valor de la observació.\nEs pot fer fàcilment amb la següent formula, i aprofitem per recordar les variables que son factors i indicar l’ordre en que volem que apareguin a posteriori:\n\nlongdata &lt;- data %&gt;% \n  pivot_longer(cols=\"gene_1\":\"gene_4\", names_to=\"gene\", values_to = \"value\" ) %&gt;% \n  mutate(\n      group = factor(group, \n                          levels = c(\"REF\", \"P\", \"G\", \"S\", \"PGS\")), \n      generation = factor(generation, \n                          levels = c( \"M\", \"Cd1\", \"Cd21\", \"CA\")),\n      gene = factor(gene,\n                    levels = c(\"gene_1\", \"gene_2\", \"gene_3\", \"gene_4\"))\n                    )\nhead(longdata) #per visualitzar-ho\n\n# A tibble: 6 × 6\n  generation group sex   rat   gene   value\n  &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;  &lt;dbl&gt;\n1 M          REF   F     R1    gene_1 105  \n2 M          REF   F     R1    gene_2  94  \n3 M          REF   F     R1    gene_3  95.2\n4 M          REF   F     R1    gene_4 101  \n5 M          REF   F     R2    gene_1  98.6\n6 M          REF   F     R2    gene_2 118. \n\n\n\ncols=\"gene_1\":\"gene_4\" ens indica quines són les columnes que contenen la variable a convertir\nnames_to=\"gene\" el nom que tindrà la nova columna que indiqui quina variable és\nvalues_to = \"value\" el nom que tindrà la columna amb els valors de la variable\n\nEn el cas que a les dades els grups o el sexe els tinguis com a número enlloc de lletres, pots canviar-ho de la següent manera\n\nmutate(\n    sex = factor(sex, \n                 levels = c(\"0\", \"1\"), #com està ara\n                 labels = c(\"Male\", \"Female\")) # a què correspon cada un\n\nRecomano guardar les dades en format long per si les necessites ja que si ho fessis a ma tindries feina…\n\nlibrary(writexl)\nwrite_xlsx(longdata,here(\"output\", \"PCR_long.xlsx\"))\n\nDe la mateixa manera que ara hem convertit de wide a long, en el cas de tenir un dataframe en format long i que el vulguem llegir de manera més fàcil, podem passar de long a wide.\n\nwidedata &lt;- longdata %&gt;%  \n  pivot_wider(names_from=\"gene\", values_from=\"value\")\nhead(widedata)\n\n# A tibble: 6 × 8\n  generation group sex   rat   gene_1 gene_2 gene_3 gene_4\n  &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 M          REF   F     R1     105     94     95.2  101  \n2 M          REF   F     R2      98.6  118.    98.1  110. \n3 M          REF   F     R6     106.    99.9   88.9   NA  \n4 M          REF   F     R8     115.    89.4   88     96.7\n5 M          REF   F     R9      97.7  108.   108.    96.1\n6 M          REF   F     R10     97.7   87.8   NA     85.4\n\n\n\nnames_from=\"gene\" per a saber d’on treurà els noms de les noves columnes que crearà\nvalues_from=\"value\" d’on treurà els valors de cada cel·la\n\n\nProblema dels NA\nÉs molt important saber en quin format tenim les dades ja que R no treballa bé amb els valors que no existeixen (NA). Com us he comentat, jo ja he fet un pre-processat de les dades, per tant he eliminat els outliers i aquelles cel·les estan buides. Al fer skim veiem a n_missing si en les nostres variables tenim alguns NA .\nPer a fer els càlculs, a R podem fer la funció na.omit() . El que fa és eliminar tota la fila en la que es trobi un NA , i per tant podrà fer els càlculs simplement sense aquella fila.\nPROBLEMA: en format wide, al eliminar una observació, elimines totes les observacions de tots els gens. Per tant si no tens el valor d’un gen però si de tots els altres, els elimines tots i perds dades.\nEn canvi, si ho fas en format long, com que cada observació només és d’un gen i el seu valor, sí que et quedes amb la resta de gens, per tant perds menys informació.\nPer això recomano sempre que es faci estadística fer-ho amb el format LONG de les dades.\n\nsummary(data) #dades originals\n\n generation group    sex         rat          gene_1          gene_2     \n CA  :20    G  :26   F:85   G1.1   :  2   Min.   : 61.3   Min.   : 67.2  \n Cd1 :40    P  :26   M:55   G3.1   :  2   1st Qu.: 93.7   1st Qu.: 97.0  \n Cd21:50    PGS:36          G8.1   :  2   Median :106.7   Median :111.4  \n M   :30    REF:36          P2.1   :  2   Mean   :115.6   Mean   :119.7  \n            S  :16          P3.1   :  2   3rd Qu.:139.2   3rd Qu.:141.2  \n                            P4.1   :  2   Max.   :170.7   Max.   :192.4  \n                            (Other):128   NA's   :13      NA's   :13     \n     gene_3          gene_4      \n Min.   : 50.7   Min.   : 67.00  \n 1st Qu.: 97.3   1st Qu.: 96.05  \n Median :109.0   Median :110.20  \n Mean   :119.5   Mean   :119.15  \n 3rd Qu.:146.5   3rd Qu.:143.40  \n Max.   :182.1   Max.   :182.60  \n NA's   :10      NA's   :13      \n\nlongdata %&gt;%\n  na.omit() %&gt;%\n  pivot_wider(names_from=\"gene\", values_from=\"value\") %&gt;% #per comparar quantes elimina i per tant amb que fariem els anàlisis\n  summary()\n\n generation group    sex         rat          gene_1          gene_2     \n M   :30    REF:36   F:85   G1.1   :  2   Min.   : 61.3   Min.   : 67.2  \n Cd1 :40    P  :26   M:55   G3.1   :  2   1st Qu.: 93.7   1st Qu.: 97.0  \n Cd21:50    G  :26          G8.1   :  2   Median :106.7   Median :111.4  \n CA  :20    S  :16          P2.1   :  2   Mean   :115.6   Mean   :119.7  \n            PGS:36          P3.1   :  2   3rd Qu.:139.2   3rd Qu.:141.2  \n                            P4.1   :  2   Max.   :170.7   Max.   :192.4  \n                            (Other):128   NA's   :13      NA's   :13     \n     gene_3          gene_4      \n Min.   : 50.7   Min.   : 67.00  \n 1st Qu.: 97.3   1st Qu.: 96.05  \n Median :109.0   Median :110.20  \n Mean   :119.5   Mean   :119.15  \n 3rd Qu.:146.5   3rd Qu.:143.40  \n Max.   :182.1   Max.   :182.60  \n NA's   :10      NA's   :13      \n\nwidedata %&gt;%\n  na.omit() %&gt;%\n  summary()\n\n generation group    sex         rat         gene_1          gene_2     \n M   :19    REF:28   F:58   G1.1   : 2   Min.   : 64.1   Min.   : 67.2  \n Cd1 :29    P  :17   M:39   G3.1   : 2   1st Qu.: 94.3   1st Qu.: 97.2  \n Cd21:36    G  :17          P4.1   : 2   Median :105.0   Median :109.8  \n CA  :13    S  :11          R1.1   : 2   Mean   :115.6   Mean   :119.9  \n            PGS:24          R1.2   : 2   3rd Qu.:139.2   3rd Qu.:140.2  \n                            R6.1   : 2   Max.   :170.7   Max.   :183.7  \n                            (Other):85                                  \n     gene_3          gene_4     \n Min.   : 50.7   Min.   : 67.0  \n 1st Qu.: 97.9   1st Qu.: 96.1  \n Median :108.5   Median :106.2  \n Mean   :118.9   Mean   :119.1  \n 3rd Qu.:146.4   3rd Qu.:144.3  \n Max.   :181.7   Max.   :182.6  \n                                \n\n\nCom podeu veure al treballar amb les dades long els resultats són els mateixos que amb les dates originals i no hem eliminat cap rata sencera. Fixeu-vos també com les dades que hem aconseguit a partir de long estan ordenades com jo volia (li he indicat al crear el dataset) i no com R vol (com en el cas de les originals).\n\n\nExemple random accions extra\nQuan estava re-aprenent-ho tot, em van fer crear un dataset nou amb moltes variables noves i altres canviades, i us ho poso d’exemple perquè sapigueu que aquestes coses es poden fer\n\ncleanbeaches_new &lt;- cleanbeaches %&gt;%  \n  separate(date, c(\"day\", \"month\", \"year\"), remove=F) %&gt;%\n  mutate(logbeachbugs = log(beachbugs)) %&gt;%\n  mutate(beachbugsdiff = beachbugs - lag(beachbugs)) %&gt;%\n  mutate(buggier_all = beachbugs &gt; mean(beachbugs, na.rm=T)) %&gt;%\n  group_by(site)%&gt;%\n  mutate(buggier_site = beachbugs &gt; mean(beachbugs, na.rm=T))\n\n\ncleanbeaches_new &lt;- cleanbeaches %&gt;% crea un dataset nou a partir de les dades cleanbeaches i aplica les següents accions\nseparate(date, c(\"day\", \"month\", \"year\"), remove=F) %&gt;% tens una columna que es diu date, separa-la en tres columnes anomenades \"day\", \"month\", \"year\" , però no m’eliminis l’original\nmutate(logbeachbugs = log(beachbugs)) %&gt;% afegeix una columna nova que es digui logbeachbugs i contingui les dades de la columna que ja existeix i es diu beachbugs però aplica la funció log(x) als seus valors.\nmutate(beachbugsdiff = beachbugs - lag(beachbugs)) %&gt;% afegeix una columna nova fent la operació x-lag(x) de les dades de la columna beachbugs\nmutate(buggier_all = beachbugs &gt; mean(beachbugs, na.rm=T)) %&gt;% afegeix una columna on indiqui si aquella observació és major a la mitjana (i al fer la mitjana no tinguis en compte els NA: na.rm=T)\ngroup_by(site)%&gt;% mutate(buggier_site = beachbugs &gt; mean(beachbugs, na.rm=T)) per començar el que facis ara agrupa-ho per site i llavors afegeix una columna que em digui si la observació és major a la mitjana només del site.\n\nAl haver fet group_by() el que es calculi a partir d’ara es calculara en els diferents sites, no a tot el dataset. Per evitar-ho despres s’ha de fer ungroup()"
  },
  {
    "objectID": "final.html",
    "href": "final.html",
    "title": "Final",
    "section": "",
    "text": "I fins aquí el que sé de Rstudio!!\nEspero que us hagi ajudat a aconseguir el que tenieu en ment!\nUna abraçada,\nElsa"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inici",
    "section": "",
    "text": "Bon dia i benvinguts al codi més interessant per a nosaltres en Rstudio. He creat aquesta web per compartir els meus coneixements adquirits al respecte i per anar-la actualitzant a mesura que n’apregui més. M’agradaria comentar que no s’ha fet desde la perfecció lingüística, sinó desde la rapidesa. Espero que no m’ho tingueu en compte.\nTant de bo us sigui útil, Elsa.\n\n\nSi sou com jo i vau aprendre R abans de que existís la intel·ligència artificial, probablement ho recordareu amb por, però això ja no és així.\nPer començar recomano sempre tenir una idea de què necessites i vols fer. Seguidament buscar a internet alguna persona que ho expliqui, ja sigui una web o un video i seguir les seves instruccions. Finalment, anar provant el codi amb les teves dades i quan trobis algun error, o vulguis canviar alguna característica, explicar-li a alguna intel·ligència artificial que tens, on vols arribar i quins problemes t’estàs trobant.\nNo recomano (de moment) anar directament a la intel·ligència artificial.\nUs deixo algunes webs que a mi em van anar bé quan vaig tornar aprendre de veritat a treballar amb Rstudio:\n\nCursos de Rstudio: https://education.rstudio.com/learn/beginner/\nBasics: https://rladiessydney.org/courses/01-basicbasics-0\nEstadística: https://learningstatisticswithr.com/book/\n\nI alguns que encara no he mirat però poden ser interessants\n\nR for data science: https://r4ds.hadley.nz/\nGgplot: https://ggplot2-book.org/\nGraph cookbook: https://r-graphics.org/index.html\nData visualization: https://socviz.co/"
  },
  {
    "objectID": "index.html#recomanacions-inicials",
    "href": "index.html#recomanacions-inicials",
    "title": "Inici",
    "section": "",
    "text": "Si sou com jo i vau aprendre R abans de que existís la intel·ligència artificial, probablement ho recordareu amb por, però això ja no és així.\nPer començar recomano sempre tenir una idea de què necessites i vols fer. Seguidament buscar a internet alguna persona que ho expliqui, ja sigui una web o un video i seguir les seves instruccions. Finalment, anar provant el codi amb les teves dades i quan trobis algun error, o vulguis canviar alguna característica, explicar-li a alguna intel·ligència artificial que tens, on vols arribar i quins problemes t’estàs trobant.\nNo recomano (de moment) anar directament a la intel·ligència artificial.\nUs deixo algunes webs que a mi em van anar bé quan vaig tornar aprendre de veritat a treballar amb Rstudio:\n\nCursos de Rstudio: https://education.rstudio.com/learn/beginner/\nBasics: https://rladiessydney.org/courses/01-basicbasics-0\nEstadística: https://learningstatisticswithr.com/book/\n\nI alguns que encara no he mirat però poden ser interessants\n\nR for data science: https://r4ds.hadley.nz/\nGgplot: https://ggplot2-book.org/\nGraph cookbook: https://r-graphics.org/index.html\nData visualization: https://socviz.co/"
  }
]