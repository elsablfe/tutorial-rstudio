---
title: "Basics"
format: 
  html:
    toc: TRUE
    toc-depth: 3
editor: visual
project:
  type: website
  output-dir: docs
---

## Instal·lació

Per començar ens haurem de descarregar:

-   R (<https://ftp.cixug.es/CRAN/index.html>)

-   Rstudio (<https://posit.co/download/rstudio-desktop/>)

Un cop ho tingueu instal·lat ja podem començar.

## Zona de treball

Tenim dues maneres de treballar, creant un projecte o agafant una carpeta qualsevol i treballant en un directori de treball.

La més senzilla és creant un directori de treball (working directory). Allà hem de tenir el nostre document .csv o .xlsx amb les dades. També serà la carpeta on ens guardarà imatges o documents en cas que ho demanem mitjançant codi.

Es pot indicar de la següent manera:

![](images/Captura%20de%20pantalla%202026-01-16%20105625-01.png){width="430"}

També es pot indicar mitjançant codi (jo ho prefereixo):

```{r, eval=FALSE}
setwd("C:/pathway que ha de seguir per arribar a la carpeta d'interés")
```

Per altre banda es pot crear un projecte (millor si ho vols tenir tot més organitzat):

![](images/Captura%20de%20pantalla%202026-01-16%20110310.png){width="317"}

En aquest cas pots crear diferents carpetes a dins del projecte directament desde la finestra de "Files" a l'extrem dret inferior. Recomano crear-ne tres mínim anomenats:

-   "data": col·locar el fitxer amb les dades

-   "scripts": on guardaràs els scripts

-   "output": on gruardar els gràfics

En el cas que feu análisis en més d'un dataset, recomano crear carpetes per a cada un, per exemple "PCR" i dins d'aquesta les tres que acabo de dir.

## Script

L'script son les instruccions que aniràs escrivint. Alguns trucs que he anat descobrint són...

Si escrius una "ordre", apareix en negre i s'executarà al tenir en cursor a la línia (o seleccionar-ne una o varies) i posar Run. Una altre manera que a mi m'agrada més és amb el teclat: **Ctrl + Enter**

```{r, eval=FALSE}
View(data) 
```

Per posar un comentari poses un `#` i tot el que estigui darrere no s'executarà

```{r, eval=FALSE}
#en aquest cas no s'executarà res

View(data) #en aquest altre cas executarà la ordre i tindràs el comentari

#View(data) aquest cas és incorrecte si vols executar l'ordre ja que no ho farà
```

Una altre característica xula és que a dins l'script pots anar creant un índex, que apareix a l'outline. Per activar-ho simplement has de colocar mínim 4 `----` al final del comentari. Al posar diferent número de `#` crearas diferent subnivells.

Això també fa que aparegui una pestanyeta a l'esquerra del títol i permetrà amagar tota aquella secció, fent la revisió i lectura de l'script sencer més còmode.

```{r, eval=FALSE}
#Títol 1 ----
## Subtítol----
### Sub-subtítol ----
#### encara més subtitol ----
#Títol 2 ----
```

![](images/Captura%20de%20pantalla%202026-01-16%20134038.png){width="194"}

## Instal·lar i carregar paquets

R té funcions bàsiques, però per fer-te la vida més fàcil molta gent ha creat funcions que et pots descarregar en paquets. El primer cop que l'utilitzis has d'instal·lar-lo i carregar-lo i els següents només carregar-lo.

```{r, eval=FALSE}
install.packages("nom paquet")
library(nom paquet)
```

Els que jo sempre utilitzo són:

```{r, eval=FALSE}
library(tidyverse) #conté 9 paquets d'edició i visualització 
library(here) #al treballar en un projecte
library(readxl) #per importar dades que estan en un fitxer d'excel
library(janitor) #ajudar a netejar les dades
library(skimr) #per obtenir un resum de les dades complert
library(broom) #poder fer servir funcions com tidy
library(rstatix) #funcions d'estadística
```

## Importar dades

Amb la zona de treball preparada i els paquets instal·lats i carregats ja podem començar a treballar, i el primer serà importar les dades.

Desde un working directory:

```{r, eval=FALSE}
raw_data<- read_excel("nom excel.xlsx", sheet = "nom full")
```

En un projecte amb el paquet `library(here)`:

```{r, eval=FALSE}
raw_data <- read_excel(here("data", "nom excel.xlsx"),  sheet = "nom full")

#en el cas de estar en una subcarpeta
raw_data <- read_excel(here("nom subcarpeta", "data", "nom excel.xlsx"),  sheet = "nom full")
```

Seguidament comprovem que s'han importat bé.

```{r, eval=FALSE}
View(raw_data) #Mirar tota la taula
head(raw_data) #imprimeix només el principi de les dades
skim(raw_data) #obtenir estadístics descriptius i característiques de les variables
```

Si tot està correcte ja podem començar amb el que vulguem.

## Descarregar dades i figures

Abans de passar a l'anàlisi de dades us indico com descarregar-vos arxius que hagueu generat:

-   Dataframes

```{r, eval=FALSE}
library(writexl)
write_xlsx(nom_dataframe, "nom fitxer.xlsx")  #amb working directory
write_xlsx(nom_dataframe, here("data", "nom fitxer.csv"))   #amb projecte
```

-   Figures amb `ggplot` (paquet inclós dins de tidyverse )

```{r, eval=FALSE}
ggsave(here("output","nom fitxer.png"), width = 12, height = 3, dpi = 300) 
#pots canviar la mida i la resolució (dpi)
```

## Altres bàsics

Finalment, escriuré funcions molt bàsiques que segurament ja conegueu però per tenir-les recollides.

R és una calculadora amb memòria per tant es poden fer operacions bàsiques, suma, resta...

Generar objectes `obj <- x` (Shortcut per a posar `<-`: alt + -)

Definir vectors `vec <- c(x, y, z)`

Definir matrius `mat <- matrix(data=c(x, y, z), nrow=X, ncol=Y)`

Accedir a elements del dataframe:

-   Columna pel nom `data$nomcolumna`

-   Element per coordenades `data[fila, columna]`

-   Rang dades `data[x:y,] #(buit=tot)`

Funcions interessants primera vista a les dades (i comprovar que tot bé)

`dim(data)` , `str(data)` , `glimpse(data)` , `head(data) / tail(data)` , `View(data)` , `glimpse(data)`

Netejar dades Netejar dades: canviar tots els caràcters dels noms de les columnes

`data <- select_all(data, tolower/toupper)`

`data <- rename(data, newname=oldname)`

Reordenar columnes o triar quines vols en un nou dataframe

`select(data, col1, col2, col3, everything())`

En el cas de resultats obtinguts, per exemple result.test, la majoria són elements tipus llista.

-   Accedir element concret: `Nomllista$nomobjecte (result.test$p.value)`

-   Veure tots elements `str(nomllista)`

Separa o ajuntar columnes (i mantenir inicial): `separate /unite (remove=F)`

Canviar o afegir columnes amb operacions `mutate`

... entre moltes d'altres que ja aniré explicant.

## Programació en R

Realment R és un llenguatge de programació, per tant es poden fer altres coses molt interessants com loops. Aquí ja no entraré però si estàs interessat que sàpiques que existeixen i a vegades el ChatGPT en crea, per tant que els sàpigues interpretar si t'apareixen.

```{r, eval=FALSE}
#Loops
while ( CONDITION ) {
  STATEMENT1
  STATEMENT2
  ETC
} #mentre la condició es compleixi anirà fent el que tingui a dins i repetirà fins que es deixi de complir

for ( VAR in VECTOR ) {
  STATEMENT1
  STATEMENT2
  ETC
} #nombre finit, per cada variable al vector farà el que li demanis fins que acabi amb totes. 

if ( CONDITION ) { #si aquesta condició es compleix farà els statement 1 i 2
  STATEMENT1
  STATEMENT2
  ETC
} else { #si no es compleix l'altre fer aquesta
  STATEMENT3
  STATEMENT4
  ETC
} 

FNAME <- function ( ARG1, ARG2, ETC ) { #funcions
  STATEMENT1
  STATEMENT2
  ETC
  return( VALUE )
}
```

Anàlisi de dades

Perfecte, doncs ara que ja sabem què és un script i com carregar dades començarem a tractar-les.

El meu tip és que tot i que per a fer un anàlisi no necessitis certes variables, tu les col·loquis totes al teu full de càlcul. En el meu cas jo estic treballant amb rates que reben una dieta materna i treballo tant amb les mares com amb la descendència. Per tant faré les següents columnes sempre:

-   **rat**: identificador de la rata

-   **generation**: a quina generació pertanyen ("M", "Cd1", "Cd21", "CA")

-   **sex**: el sexe de la rata ("M", "F", "ns")

-   **group**: a quin grup de dieta pertanyen ("REF", "P", "G", "S", "PGS")

-   **variables d'interés**: columnes diferents amb títol de cada variable i els valors que ha obtingut cada rata.

    -   PCR: una columna per cada gen

    -   Lipidòmica: una columna per cada lípid

    -   Beads: una columna per cada Ig

    -   i un llarg etcètera

Si un dia jo només tinc rates que son de la generació "M", igualment fer una columna i indicar-ho, ja que un cop a dins de R, podem treure columnes si no ens interessen, o ajuntar dos datasets diferents on llavors potser sí que és interessant tenir aquesta informació.

El que si que no recomano és tenir dues columnes amb la mateixa informació, com per exemple una columna on el grup estigui codificat amb lletres i una altre amb números. Si en algun moment ho necessitem, simplement mutarem la columna existent i ja està.

Una altre recomanació és fer els noms de columnes, i les variables a dins seu, el més simple possible. Això és degut a que després, quan creem el codi, segurament ho haurem d'escriure EXACTAMENT igual, per tant com més simple menys maldecaps. Si esteu fent servir algun dataset que no teniu preparat per això no us preocupeu, hi ha maneres de fer-lo més simple dins d'R.

-   *grup* enlloc de *Grup*

-   *M* enlloc de *Mascles*

A més a més el meu dataset és complicat ja que no tinc el mateix nombre de grups per cada generació. Aquí teniu una taula resum que serà útil per entendre els anàlisis estadístics posteriors.

| Generació | Grups             | Sexe | Rates per grup |
|-----------|-------------------|------|----------------|
| M         | REF, P, G, S, PGS | F    | 6              |
| Cd1       | REF, P, G, PGS    | M, F | 10             |
| Cd21      | REF, P, G, S, PGS | M, F | 10             |
| CA        | REF, PGS          | M, F | 10             |

Per a que no hi hagi problemes de filtració de dades li he demanat a ChatGPT que em crei un dataset d'aquestes característiques, així que totes les dades que faré servir i els resultats són inventats.

Això si, jo ja he fet un pre-processat de les dades amb l'excel en el que he tret els outliers de cada grup (per tant alguna cel·la estarà buida i tindré `NA`) i els valors que introdueixo són expressió relativa respecte el grup REF de la seva generació, en %. Si no ho teniu fet es podria fer tot dins de l'R però jo per començar no m'he complicat tant.

L'excel llueix així:

![](images/Captura%20de%20pantalla%202026-01-16%20155245.png){width="459"}

Importem les dades i comprovem que estan bé i els grups que existeixen corresponen al que hem indicat:

```{r, warning=FALSE, message=FALSE}
library(readxl)
library(here)
raw_data <- read_excel(here("Basic", "data", "PCR.xlsx"),  sheet = "relative")
View(raw_data)
library(skimr)
skim(raw_data)
```

Com veiem, ens ha fet un resum general de les dades i variables, totes com a conjunt.

Anem a teure'ls-hi suc.

# Transformar el dataset

## Tidyverse

Per tal de fer-nos la vida més fàcil, altre gent que treballa amb R ha creat el paquet `tidyverse` el qual, com ja he dit, conté els paquets més importants per a transformar dades i graficar-les. També hi ha gent molt generosa que ha fet CheatSheets dels paquets més útils, que us recomano imprimir i tenir sempre a mà: <https://posit.co/resources/cheatsheets/>

```{r, warning=FALSE}
library(tidyverse) 
library(janitor)
library(broom) 
library(rstatix)
```

Una de les característiques més interessants és la pipeline `%>%` (o ara més nou de R `|>` ). Aquesta funció del paquet `dyplr` permet enllaçar moltes accions i que vagin succeint de manera seqüencial en un dataframe.

Primer s'indica el dataframe i després comeces a fer accions. Per tant dins d'aquestes accions ja no cal que indiquis quin dataset ha d'agafar.

Per altra banda pots fer certes accions a partir de condicions que es troben en un altre dataset (ja ho veurem més endavant).

## Crear nous dataset

El següent pas un cop hem importat el dataset és determinar quin tipus de variable és cada una, i a mi m'agrada crear un nou dataset amb les modificacions i deixar el `raw_data` intacte per si en algun moment necessitem alguna dada o fem modificacions irreversibles sense voler no haver de tornar a importar.

Si volem grardar el nou dataset és important posar davant de l'acció data `nom_dataset <-` d'aquesta manera crearem un dataset amb el nom que triem amb les accions que hem indicat.

```{r, warning=FALSE, message=FALSE}
data <- raw_data %>% #farà les accions sobre el dataset anomenat raw_data
  mutate(across(c(group, sex, rat, generation), as.factor)) #definir totes les variables que son factors
skim(data)
```

Si tenim noms molt complicats, podem afegir abans`clean_names()` i posa tots els noms de columna en minuscula i sense espais, per fer més fàcil el codi, necessita paquet `janitor`

Si us hi fixeu ara les variables que eren de categoria `character` per defecte, ara son `factor` i ja es veuen els nivells.

### Filtrar dades

Si per exemple volem extreure només les dades de la generació "M" podriem crear un altre dataset de la següent manera:

```{r}
dams <- data %>% 
  filter(generation == "M")  
skim(dams)
```

La funció `filter()` és molt interessant ja que podem fer-ho de una variable només un nivell amb `== "nom variable"` o de diferents nivells `%in%c("nom1", "nom2")` i alhora de diferents variables i diferents nivells

```{r}
data %>% 
  filter(generation  %in% c("M", "CA"), group == "REF" )  
```

Fixeu-vos que en aquest cas m'ho ensenya directament. Això és degut a que no m'ho està guardant com a dataframe perquè no he posat `nom_dataset <-` davant de les dades. Pot ser útil per comprovar si el teu codi fa el que vols abans de crear el dataframe.

## Wide format vs Long format

Un concepte molt important a l'hora de utilitzar R és el wide dataset vs long dataset.

![](images/Captura%20de%20pantalla%202026-01-16%20162651.png){width="435"}

En aquesta imatge tenim a l'**esquerra** el format **wide**, que és el que estem més acostumats a crear en excel, i a la **dreta** el format **long**, el qual és el que li va millor a R per la majoria de funcions. En el nostre cas li hem donat una taula en format wide ja que tenim una rata a cada fila, i tenim una columna per a cada variable de gen. Per a tenir-ho en format long volem una columna que ens digui de quin gen es tracta aquella observació i una altre columna amb el valor de la observació.

Es pot fer fàcilment amb la següent formula, i aprofitem per recordar les variables que son factors i indicar l'ordre en que volem que apareguin a posteriori:

```{r}
longdata <- data %>% 
  pivot_longer(cols="gene_1":"gene_4", names_to="gene", values_to = "value" ) %>% 
  mutate(
      group = factor(group, 
                          levels = c("REF", "P", "G", "S", "PGS")), 
      generation = factor(generation, 
                          levels = c( "M", "Cd1", "Cd21", "CA")),
      gene = factor(gene,
                    levels = c("gene_1", "gene_2", "gene_3", "gene_4"))
                    )
head(longdata) #per visualitzar-ho
```

-   `cols="gene_1":"gene_4"` ens indica quines són les columnes que contenen la variable a convertir

-   `names_to="gene"` el nom que tindrà la nova columna que indiqui quina variable és

-   `values_to = "value"` el nom que tindrà la columna amb els valors de la variable

En el cas que a les dades els grups o el sexe els tinguis com a número enlloc de lletres, pots canviar-ho de la següent manera

```{r, eval=FALSE}
mutate(
    sex = factor(sex, 
                 levels = c("0", "1"), #com està ara
                 labels = c("Male", "Female")) # a què correspon cada un
```

Recomano guardar les dades en format long per si les necessites ja que si ho fessis a ma tindries feina...

```{r, warning=FALSE, message=FALSE,eval=FALSE}
library(writexl)
write_xlsx(longdata,here("output", "PCR_long.xlsx"))
```

De la mateixa manera que ara hem convertit de wide a long, en el cas de tenir un dataframe en format long i que el vulguem llegir de manera més fàcil, podem passar **de long a wide.**

```{r}
widedata <- longdata %>%  
  pivot_wider(names_from="gene", values_from="value")
head(widedata)
```

-   `names_from="gene"` per a saber d'on treurà els noms de les noves columnes que crearà

-   `values_from="value"` d'on treurà els valors de cada cel·la

### Problema dels NA

És molt important saber en quin format tenim les dades ja que R no treballa bé amb els valors que no existeixen (`NA`). Com us he comentat, jo ja he fet un pre-processat de les dades, per tant he eliminat els outliers i aquelles cel·les estan buides. Al fer `skim` veiem a `n_missing` si en les nostres variables tenim alguns `NA` .

Per a fer els càlculs, a R podem fer la funció `na.omit()` . El que fa és eliminar tota la fila en la que es trobi un `NA` , i per tant podrà fer els càlculs simplement sense aquella fila.

PROBLEMA: en format wide, al eliminar una observació, elimines totes les observacions de tots els gens. Per tant si no tens el valor d'un gen però si de tots els altres, els elimines tots i perds dades.

En canvi, si ho fas en format long, com que cada observació només és d'un gen i el seu valor, sí que et quedes amb la resta de gens, per tant perds menys informació.

Per això recomano sempre que es faci estadística fer-ho amb el format LONG de les dades.

```{r}
summary(data) #dades originals

longdata %>%
  na.omit() %>%
  pivot_wider(names_from="gene", values_from="value") %>% #per comparar quantes elimina i per tant amb que fariem els anàlisis
  summary()

widedata %>%
  na.omit() %>%
  summary()
```

Com podeu veure al treballar amb les dades long els resultats són els mateixos que amb les dates originals i no hem eliminat cap rata sencera. Fixeu-vos també com les dades que hem aconseguit a partir de long estan ordenades com jo volia (li he indicat al crear el dataset) i no com R vol (com en el cas de les originals).

### Exemple random accions extra

Quan estava re-aprenent-ho tot, em van fer crear un dataset nou amb moltes variables noves i altres canviades, i us ho poso d'exemple perquè sapigueu que aquestes coses es poden fer

```{r, eval=FALSE}
cleanbeaches_new <- cleanbeaches %>%  
  separate(date, c("day", "month", "year"), remove=F) %>%
  mutate(logbeachbugs = log(beachbugs)) %>%
  mutate(beachbugsdiff = beachbugs - lag(beachbugs)) %>%
  mutate(buggier_all = beachbugs > mean(beachbugs, na.rm=T)) %>%
  group_by(site)%>%
  mutate(buggier_site = beachbugs > mean(beachbugs, na.rm=T))
```

-   `cleanbeaches_new <- cleanbeaches %>%` crea un dataset nou a partir de les dades cleanbeaches i aplica les següents accions

-   `separate(date, c("day", "month", "year"), remove=F) %>%` tens una columna que es diu `date`, separa-la en tres columnes anomenades `"day", "month", "year"` , però no m'eliminis l'original

-   `mutate(logbeachbugs = log(beachbugs)) %>%` afegeix una columna nova que es digui `logbeachbugs` i contingui les dades de la columna que ja existeix i es diu `beachbugs` però aplica la funció `log(x)` als seus valors.

-   `mutate(beachbugsdiff = beachbugs - lag(beachbugs)) %>%` afegeix una columna nova fent la operació `x-lag(x)` de les dades de la columna beachbugs

-   `mutate(buggier_all = beachbugs > mean(beachbugs, na.rm=T)) %>%` afegeix una columna on indiqui si aquella observació és major a la mitjana (i al fer la mitjana no tinguis en compte els NA: `na.rm=T`)

-   `group_by(site)%>% mutate(buggier_site = beachbugs > mean(beachbugs, na.rm=T))` per començar el que facis ara agrupa-ho per site i llavors afegeix una columna que em digui si la observació és major a la mitjana només del site.

    -   Al haver fet `group_by()` el que es calculi a partir d'ara es calculara en els diferents sites, no a tot el dataset. Per evitar-ho despres s'ha de fer `ungroup()`
